{"version":3,"file":"index-legacy-DSdvVKTb.js","sources":["../../src/core/Physics.js","../../src/core/ParticleSystem.js","../../src/components/Player.js","../../src/main.js"],"sourcesContent":["/**\n * Physics Engine for Ocean Adventure\n *\n * Implements collision detection and underwater physics simulation\n * including buoyancy, drag, and environmental forces.\n */\n\nimport * as THREE from 'three'\n\n/**\n * Collision system supporting AABB and sphere-based collision detection\n */\nexport class CollisionSystem {\n  constructor() {\n    this.colliders = []\n    this.staticColliders = []\n  }\n\n  /**\n   * Add a collider to the system\n   * @param {Object} collider - Collider object with geometry and position\n   * @param {boolean} isStatic - Whether the collider is static (doesn't move)\n   */\n  addCollider(collider, isStatic = false) {\n    const list = isStatic ? this.staticColliders : this.colliders\n    list.push(collider)\n  }\n\n  /**\n   * Remove a collider from the system\n   * @param {Object} collider - Collider to remove\n   */\n  removeCollider(collider) {\n    let index = this.colliders.indexOf(collider)\n    if (index !== -1) {\n      this.colliders.splice(index, 1)\n      return\n    }\n\n    index = this.staticColliders.indexOf(collider)\n    if (index !== -1) {\n      this.staticColliders.splice(index, 1)\n    }\n  }\n\n  /**\n   * Check for collisions between two objects\n   * @param {Object} objectA - First object with position and geometry\n   * @param {Object} objectB - Second object with position and geometry\n   * @returns {boolean} Whether objects are colliding\n   */\n  checkCollision(objectA, objectB) {\n    // Sphere-sphere collision detection\n    if (\n      objectA.collisionType === 'sphere' &&\n      objectB.collisionType === 'sphere'\n    ) {\n      return this.checkSphereCollision(objectA, objectB)\n    }\n\n    // AABB-AABB collision detection\n    if (objectA.collisionType === 'box' && objectB.collisionType === 'box') {\n      return this.checkAABBCollision(objectA, objectB)\n    }\n\n    // Sphere-AABB collision detection\n    if (\n      (objectA.collisionType === 'sphere' && objectB.collisionType === 'box') ||\n      (objectA.collisionType === 'box' && objectB.collisionType === 'sphere')\n    ) {\n      return this.checkSphereAABBCollision(objectA, objectB)\n    }\n\n    return false\n  }\n\n  /**\n   * Check sphere-sphere collision\n   * @param {Object} sphereA - First sphere\n   * @param {Object} sphereB - Second sphere\n   * @returns {boolean} Whether spheres are colliding\n   */\n  checkSphereCollision(sphereA, sphereB) {\n    const distance = sphereA.position.distanceTo(sphereB.position)\n    const radiusSum = sphereA.radius + sphereB.radius\n    return distance <= radiusSum\n  }\n\n  /**\n   * Check AABB-AABB collision\n   * @param {Object} boxA - First box\n   * @param {Object} boxB - Second box\n   * @returns {boolean} Whether boxes are colliding\n   */\n  checkAABBCollision(boxA, boxB) {\n    const minA = boxA.position\n      .clone()\n      .sub(boxA.size.clone().multiplyScalar(0.5))\n    const maxA = boxA.position\n      .clone()\n      .add(boxA.size.clone().multiplyScalar(0.5))\n    const minB = boxB.position\n      .clone()\n      .sub(boxB.size.clone().multiplyScalar(0.5))\n    const maxB = boxB.position\n      .clone()\n      .add(boxB.size.clone().multiplyScalar(0.5))\n\n    return (\n      minA.x <= maxB.x &&\n      maxA.x >= minB.x &&\n      minA.y <= maxB.y &&\n      maxA.y >= minB.y &&\n      minA.z <= maxB.z &&\n      maxA.z >= minB.z\n    )\n  }\n\n  /**\n   * Check sphere-AABB collision\n   * @param {Object} objectA - First object (sphere or box)\n   * @param {Object} objectB - Second object (sphere or box)\n   * @returns {boolean} Whether objects are colliding\n   */\n  checkSphereAABBCollision(objectA, objectB) {\n    const sphere = objectA.collisionType === 'sphere' ? objectA : objectB\n    const box = objectA.collisionType === 'box' ? objectA : objectB\n\n    const boxMin = box.position\n      .clone()\n      .sub(box.size.clone().multiplyScalar(0.5))\n    const boxMax = box.position\n      .clone()\n      .add(box.size.clone().multiplyScalar(0.5))\n\n    // Find closest point on box to sphere center\n    const closestPoint = new THREE.Vector3(\n      Math.max(boxMin.x, Math.min(sphere.position.x, boxMax.x)),\n      Math.max(boxMin.y, Math.min(sphere.position.y, boxMax.y)),\n      Math.max(boxMin.z, Math.min(sphere.position.z, boxMax.z))\n    )\n\n    const distance = sphere.position.distanceTo(closestPoint)\n    return distance <= sphere.radius\n  }\n\n  /**\n   * Check all collisions for a given object\n   * @param {Object} object - Object to check collisions for\n   * @returns {Array} Array of colliding objects\n   */\n  checkCollisions(object) {\n    const collisions = []\n\n    // Check against dynamic colliders\n    for (const collider of this.colliders) {\n      if (collider !== object && this.checkCollision(object, collider)) {\n        collisions.push(collider)\n      }\n    }\n\n    // Check against static colliders\n    for (const collider of this.staticColliders) {\n      if (this.checkCollision(object, collider)) {\n        collisions.push(collider)\n      }\n    }\n\n    return collisions\n  }\n}\n\n/**\n * Underwater physics simulation\n */\nexport class UnderwaterPhysics {\n  constructor() {\n    this.buoyancyForce = 2.0 // Further reduced buoyancy force (was 4.0)\n    this.dragCoefficient = 0.95 // Water resistance (0-1, lower = more drag)\n    this.currentDirection = new THREE.Vector3(0.1, 0, 0.05) // Gentle underwater current\n    this.currentStrength = 0.02\n  }\n\n  /**\n   * Apply buoyancy force to an object\n   * @param {Object} body - Physics body with velocity and position\n   * @param {number} deltaTime - Time since last frame\n   */\n  applyBuoyancy(body, deltaTime) {\n    const buoyancy = new THREE.Vector3(0, this.buoyancyForce * deltaTime, 0)\n    body.velocity.add(buoyancy)\n  }\n\n  /**\n   * Apply drag force to an object\n   * @param {Object} body - Physics body with velocity\n   */\n  applyDrag(body) {\n    body.velocity.multiplyScalar(this.dragCoefficient)\n  }\n\n  /**\n   * Apply underwater current to an object\n   * @param {Object} body - Physics body with velocity\n   * @param {number} currentStrength - Strength multiplier for current effect\n   * @param {number} deltaTime - Time since last frame\n   */\n  applyCurrent(body, currentStrength = 1.0, deltaTime) {\n    const currentForce = this.currentDirection\n      .clone()\n      .multiplyScalar(this.currentStrength * currentStrength * deltaTime)\n    body.velocity.add(currentForce)\n  }\n\n  /**\n   * Apply all underwater physics effects\n   * @param {Object} body - Physics body\n   * @param {number} deltaTime - Time since last frame\n   */\n  applyUnderwaterEffects(body, deltaTime) {\n    this.applyBuoyancy(body, deltaTime)\n    this.applyDrag(body)\n    this.applyCurrent(body, 1.0, deltaTime)\n  }\n}\n\n/**\n * Main Physics Engine\n */\nexport class PhysicsEngine {\n  constructor() {\n    this.gravity = new THREE.Vector3(0, -9.8, 0)\n    this.waterDensity = 1000 // kg/m¬≥\n    this.collisionSystem = new CollisionSystem()\n    this.underwaterPhysics = new UnderwaterPhysics()\n    this.rigidBodies = []\n    this.isUnderwater = true // For now, everything is underwater\n  }\n\n  /**\n   * Add a rigid body to the physics simulation\n   * @param {Object} body - Physics body to add\n   */\n  addRigidBody(body) {\n    this.rigidBodies.push(body)\n\n    // Add to collision system if it has collision properties\n    if (body.collisionType) {\n      this.collisionSystem.addCollider(body, body.isStatic)\n    }\n  }\n\n  /**\n   * Remove a rigid body from the physics simulation\n   * @param {Object} body - Physics body to remove\n   */\n  removeRigidBody(body) {\n    const index = this.rigidBodies.indexOf(body)\n    if (index !== -1) {\n      this.rigidBodies.splice(index, 1)\n      this.collisionSystem.removeCollider(body)\n    }\n  }\n\n  /**\n   * Update all physics bodies\n   * @param {number} deltaTime - Time since last frame\n   */\n  update(deltaTime) {\n    for (const body of this.rigidBodies) {\n      this.updateBody(body, deltaTime)\n    }\n  }\n\n  /**\n   * Update a single physics body\n   * @param {Object} body - Physics body to update\n   * @param {number} deltaTime - Time since last frame\n   */\n  updateBody(body, deltaTime) {\n    if (body.isStatic) {\n      return\n    }\n\n    // Initialize velocity if not present\n    if (!body.velocity) {\n      body.velocity = new THREE.Vector3()\n    }\n\n    // Store previous position for collision resolution\n    const previousPosition = body.position.clone()\n\n    // Apply forces based on environment\n    if (this.isUnderwater) {\n      this.underwaterPhysics.applyUnderwaterEffects(body, deltaTime)\n    } else {\n      // Apply gravity in air\n      const gravityForce = this.gravity.clone().multiplyScalar(deltaTime)\n      body.velocity.add(gravityForce)\n    }\n\n    // Apply velocity to position\n    const velocityDelta = body.velocity.clone().multiplyScalar(deltaTime)\n    body.position.add(velocityDelta)\n\n    // Check collisions and resolve\n    const collisions = this.collisionSystem.checkCollisions(body)\n    if (collisions.length > 0) {\n      this.resolveCollisions(body, collisions, previousPosition)\n    }\n  }\n\n  /**\n   * Resolve collisions for a body\n   * @param {Object} body - Physics body that collided\n   * @param {Array} collisions - Array of colliding objects\n   * @param {THREE.Vector3} previousPosition - Position before collision\n   */\n  resolveCollisions(body, collisions, previousPosition) {\n    // Simple collision resolution: revert to previous position and stop movement\n    body.position.copy(previousPosition)\n\n    // Reduce velocity on collision (bounce/friction)\n    body.velocity.multiplyScalar(0.3)\n\n    // Notify collision callbacks if present\n    if (body.onCollision) {\n      body.onCollision(collisions)\n    }\n  }\n\n  /**\n   * Check collisions for all bodies\n   * @returns {Array} Array of collision pairs\n   */\n  checkCollisions() {\n    const collisionPairs = []\n\n    for (let i = 0; i < this.rigidBodies.length; i++) {\n      const bodyA = this.rigidBodies[i]\n      const collisions = this.collisionSystem.checkCollisions(bodyA)\n\n      for (const bodyB of collisions) {\n        collisionPairs.push([bodyA, bodyB])\n      }\n    }\n\n    return collisionPairs\n  }\n\n  /**\n   * Create a sphere collision body\n   * @param {THREE.Vector3} position - Position of the sphere\n   * @param {number} radius - Radius of the sphere\n   * @param {boolean} isStatic - Whether the body is static\n   * @returns {Object} Collision body\n   */\n  createSphereBody(position, radius, isStatic = false) {\n    return {\n      position: position.clone(),\n      velocity: new THREE.Vector3(),\n      collisionType: 'sphere',\n      radius: radius,\n      isStatic: isStatic,\n    }\n  }\n\n  /**\n   * Create a box collision body\n   * @param {THREE.Vector3} position - Position of the box\n   * @param {THREE.Vector3} size - Size of the box\n   * @param {boolean} isStatic - Whether the body is static\n   * @returns {Object} Collision body\n   */\n  createBoxBody(position, size, isStatic = false) {\n    return {\n      position: position.clone(),\n      velocity: new THREE.Vector3(),\n      collisionType: 'box',\n      size: size.clone(),\n      isStatic: isStatic,\n    }\n  }\n}\n","/**\n * Particle System for Ocean Adventure\n *\n * Creates underwater atmosphere with bubbles, light rays,\n * and collection effects for enhanced immersion.\n */\n\nimport * as THREE from 'three'\n\n/**\n * Individual particle class\n */\nclass Particle {\n  constructor(position, velocity, life, size, color) {\n    this.position = position.clone()\n    this.velocity = velocity.clone()\n    this.life = life\n    this.maxLife = life\n    this.size = size\n    this.color = color.clone()\n    this.alpha = 1.0\n    this.active = true\n  }\n\n  /**\n   * Update particle state\n   * @param {number} deltaTime - Time since last frame\n   */\n  update(deltaTime) {\n    if (!this.active) {\n      return\n    }\n\n    // Update position\n    this.position.add(this.velocity.clone().multiplyScalar(deltaTime))\n\n    // Update life\n    this.life -= deltaTime\n\n    // Update alpha based on life remaining\n    this.alpha = this.life / this.maxLife\n\n    // Deactivate particle if life is over\n    if (this.life <= 0) {\n      this.active = false\n    }\n  }\n\n  /**\n   * Reset particle with new properties\n   * @param {THREE.Vector3} position - New position\n   * @param {THREE.Vector3} velocity - New velocity\n   * @param {number} life - New life span\n   * @param {number} size - New size\n   * @param {THREE.Color} color - New color\n   */\n  reset(position, velocity, life, size, color) {\n    this.position.copy(position)\n    this.velocity.copy(velocity)\n    this.life = life\n    this.maxLife = life\n    this.size = size\n    this.color.copy(color)\n    this.alpha = 1.0\n    this.active = true\n  }\n}\n\n/**\n * Main particle system class\n */\nexport class ParticleSystem {\n  constructor(scene, maxParticles = 1000) {\n    this.scene = scene\n    this.maxParticles = maxParticles\n    this.particles = []\n    this.emitters = []\n\n    // Create particle pool\n    this.initializeParticlePool()\n\n    // Create particle geometry and material\n    this.createParticleRenderSystem()\n\n    // Add default underwater emitters\n    this.createUnderwaterEmitters()\n  }\n\n  /**\n   * Initialize the particle pool for object reuse\n   */\n  initializeParticlePool() {\n    for (let i = 0; i < this.maxParticles; i++) {\n      const particle = new Particle(\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        1.0,\n        1.0,\n        new THREE.Color(0xffffff)\n      )\n      particle.active = false\n      this.particles.push(particle)\n    }\n  }\n\n  /**\n   * Create the rendering system for particles\n   */\n  createParticleRenderSystem() {\n    // Create geometry for point sprites\n    this.geometry = new THREE.BufferGeometry()\n\n    // Create arrays for particle attributes\n    this.positions = new Float32Array(this.maxParticles * 3)\n    this.colors = new Float32Array(this.maxParticles * 3)\n    this.sizes = new Float32Array(this.maxParticles)\n    this.alphas = new Float32Array(this.maxParticles)\n\n    // Set attributes\n    this.geometry.setAttribute(\n      'position',\n      new THREE.BufferAttribute(this.positions, 3)\n    )\n    this.geometry.setAttribute(\n      'color',\n      new THREE.BufferAttribute(this.colors, 3)\n    )\n    this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1))\n    this.geometry.setAttribute(\n      'alpha',\n      new THREE.BufferAttribute(this.alphas, 1)\n    )\n\n    // Create shader material for better underwater effects\n    this.material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0.0 },\n        pointTexture: { value: this.createParticleTexture() },\n      },\n      vertexShader: `\n        attribute float size;\n        attribute float alpha;\n        varying float vAlpha;\n        varying vec3 vColor;\n        \n        void main() {\n          vAlpha = alpha;\n          vColor = color;\n          \n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_PointSize = size * (300.0 / -mvPosition.z);\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        uniform sampler2D pointTexture;\n        varying float vAlpha;\n        varying vec3 vColor;\n        \n        void main() {\n          vec4 texColor = texture2D(pointTexture, gl_PointCoord);\n          gl_FragColor = vec4(vColor, vAlpha * texColor.a);\n        }\n      `,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false,\n    })\n\n    // Create points object\n    this.points = new THREE.Points(this.geometry, this.material)\n    this.scene.add(this.points)\n  }\n\n  /**\n   * Create texture for particles\n   * @returns {THREE.Texture} Particle texture\n   */\n  createParticleTexture() {\n    const canvas = document.createElement('canvas')\n    canvas.width = 64\n    canvas.height = 64\n\n    const context = canvas.getContext('2d')\n    const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32)\n    gradient.addColorStop(0, 'rgba(255,255,255,1)')\n    gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)')\n    gradient.addColorStop(0.4, 'rgba(255,255,255,0.4)')\n    gradient.addColorStop(1, 'rgba(255,255,255,0)')\n\n    context.fillStyle = gradient\n    context.fillRect(0, 0, 64, 64)\n\n    const texture = new THREE.Texture(canvas)\n    texture.needsUpdate = true\n    return texture\n  }\n\n  /**\n   * Create underwater particle emitters\n   */\n  createUnderwaterEmitters() {\n    // Bubble emitter\n    this.addEmitter({\n      type: 'bubbles',\n      position: new THREE.Vector3(0, -10, 0),\n      rate: 5, // particles per second\n      life: 8.0,\n      size: { min: 2, max: 6 },\n      velocity: new THREE.Vector3(0, 2, 0),\n      velocityVariation: new THREE.Vector3(0.5, 0.5, 0.5),\n      color: new THREE.Color(0x87ceeb),\n      colorVariation: 0.1,\n      area: new THREE.Vector3(20, 2, 20), // Emission area\n    })\n\n    // Floating particles (debris/plankton)\n    this.addEmitter({\n      type: 'debris',\n      position: new THREE.Vector3(0, 0, 0),\n      rate: 3,\n      life: 15.0,\n      size: { min: 1, max: 3 },\n      velocity: new THREE.Vector3(0.1, 0.05, 0.1),\n      velocityVariation: new THREE.Vector3(0.3, 0.2, 0.3),\n      color: new THREE.Color(0xffffff),\n      colorVariation: 0.2,\n      area: new THREE.Vector3(40, 20, 40),\n    })\n\n    // Light rays effect (very sparse)\n    this.addEmitter({\n      type: 'lightRays',\n      position: new THREE.Vector3(0, 15, 0),\n      rate: 0.5,\n      life: 20.0,\n      size: { min: 8, max: 15 },\n      velocity: new THREE.Vector3(0, -0.5, 0),\n      velocityVariation: new THREE.Vector3(0.1, 0.2, 0.1),\n      color: new THREE.Color(0xffd700),\n      colorVariation: 0.1,\n      area: new THREE.Vector3(30, 5, 30),\n    })\n  }\n\n  /**\n   * Add a particle emitter\n   * @param {Object} emitterConfig - Configuration for the emitter\n   */\n  addEmitter(emitterConfig) {\n    const emitter = {\n      ...emitterConfig,\n      accumulator: 0.0, // For rate control\n      active: true,\n    }\n    this.emitters.push(emitter)\n  }\n\n  /**\n   * Emit a single particle\n   * @param {Object} emitter - Emitter configuration\n   */\n  emitParticle(emitter) {\n    // Find inactive particle\n    const particle = this.particles.find(p => !p.active)\n    if (!particle) {\n      return\n    } // No available particles\n\n    // Calculate random position within emission area\n    const position = emitter.position\n      .clone()\n      .add(\n        new THREE.Vector3(\n          (Math.random() - 0.5) * emitter.area.x,\n          (Math.random() - 0.5) * emitter.area.y,\n          (Math.random() - 0.5) * emitter.area.z\n        )\n      )\n\n    // Calculate random velocity\n    const velocity = emitter.velocity\n      .clone()\n      .add(\n        new THREE.Vector3(\n          (Math.random() - 0.5) * emitter.velocityVariation.x,\n          (Math.random() - 0.5) * emitter.velocityVariation.y,\n          (Math.random() - 0.5) * emitter.velocityVariation.z\n        )\n      )\n\n    // Calculate random size\n    const size =\n      emitter.size.min + Math.random() * (emitter.size.max - emitter.size.min)\n\n    // Calculate random color\n    const color = emitter.color.clone()\n    if (emitter.colorVariation > 0) {\n      color.offsetHSL(\n        (Math.random() - 0.5) * emitter.colorVariation,\n        0,\n        (Math.random() - 0.5) * emitter.colorVariation * 0.5\n      )\n    }\n\n    // Reset particle with new properties\n    particle.reset(position, velocity, emitter.life, size, color)\n  }\n\n  /**\n   * Create a burst of particles at a specific location\n   * @param {THREE.Vector3} position - Position to emit particles\n   * @param {Object} config - Burst configuration\n   */\n  createBurst(position, config = {}) {\n    const count = config.count || 20\n    const life = config.life || 2.0\n    const velocity = config.velocity || new THREE.Vector3(0, 1, 0)\n    const velocityVariation =\n      config.velocityVariation || new THREE.Vector3(2, 2, 2)\n    const color = config.color || new THREE.Color(0xffd700)\n    const size = config.size || { min: 2, max: 8 }\n\n    for (let i = 0; i < count; i++) {\n      const particle = this.particles.find(p => !p.active)\n      if (!particle) {\n        break\n      }\n\n      const burstVelocity = velocity\n        .clone()\n        .add(\n          new THREE.Vector3(\n            (Math.random() - 0.5) * velocityVariation.x,\n            (Math.random() - 0.5) * velocityVariation.y,\n            (Math.random() - 0.5) * velocityVariation.z\n          )\n        )\n\n      const particleSize = size.min + Math.random() * (size.max - size.min)\n\n      particle.reset(position.clone(), burstVelocity, life, particleSize, color)\n    }\n  }\n\n  /**\n   * Update particle system\n   * @param {number} deltaTime - Time since last frame\n   */\n  update(deltaTime) {\n    // Update emitters\n    for (const emitter of this.emitters) {\n      if (!emitter.active) {\n        continue\n      }\n\n      emitter.accumulator += deltaTime\n      const emissionInterval = 1.0 / emitter.rate\n\n      while (emitter.accumulator >= emissionInterval) {\n        this.emitParticle(emitter)\n        emitter.accumulator -= emissionInterval\n      }\n    }\n\n    // Update particles\n    let activeCount = 0\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i]\n\n      if (particle.active) {\n        particle.update(deltaTime)\n\n        // Update render attributes\n        const index3 = activeCount * 3\n        this.positions[index3] = particle.position.x\n        this.positions[index3 + 1] = particle.position.y\n        this.positions[index3 + 2] = particle.position.z\n\n        this.colors[index3] = particle.color.r\n        this.colors[index3 + 1] = particle.color.g\n        this.colors[index3 + 2] = particle.color.b\n\n        this.sizes[activeCount] = particle.size\n        this.alphas[activeCount] = particle.alpha\n\n        activeCount++\n      }\n    }\n\n    // Update geometry\n    this.geometry.attributes.position.needsUpdate = true\n    this.geometry.attributes.color.needsUpdate = true\n    this.geometry.attributes.size.needsUpdate = true\n    this.geometry.attributes.alpha.needsUpdate = true\n\n    // Update draw range to only render active particles\n    this.geometry.setDrawRange(0, activeCount)\n\n    // Update shader uniforms\n    this.material.uniforms.time.value += deltaTime\n  }\n\n  /**\n   * Set emitter active state\n   * @param {string} type - Emitter type\n   * @param {boolean} active - Whether emitter should be active\n   */\n  setEmitterActive(type, active) {\n    const emitter = this.emitters.find(e => e.type === type)\n    if (emitter) {\n      emitter.active = active\n    }\n  }\n\n  /**\n   * Remove all particles\n   */\n  clear() {\n    for (const particle of this.particles) {\n      particle.active = false\n    }\n  }\n\n  /**\n   * Dispose of particle system resources\n   */\n  dispose() {\n    this.scene.remove(this.points)\n    this.geometry.dispose()\n    this.material.dispose()\n    if (this.material.uniforms.pointTexture.value) {\n      this.material.uniforms.pointTexture.value.dispose()\n    }\n  }\n}\n","/**\n * Player Component for Ocean Adventure\n *\n * Enhanced player controller with physics integration,\n * underwater movement mechanics, and collision handling.\n */\n\nimport * as THREE from 'three'\n\nexport class Player {\n  constructor(scene, physicsEngine) {\n    this.scene = scene\n    this.physicsEngine = physicsEngine\n\n    // Player properties\n    this.moveSpeed = 8.0\n    this.rotationSpeed = 3.0\n    this.maxVelocity = 5.0\n\n    // Movement state\n    this.movementVector = new THREE.Vector3()\n    this.isMoving = false\n\n    // Create player mesh and physics body\n    this.createPlayerMesh()\n    this.createPhysicsBody()\n\n    // Bind collision handler\n    this.physicsBody.onCollision = collisions =>\n      this.handleCollisions(collisions)\n  }\n\n  /**\n   * Create the visual representation of the player\n   */\n  createPlayerMesh() {\n    // Create player geometry (capsule for better collision detection)\n    const geometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8)\n\n    // Use MeshPhongMaterial for better lighting effects\n    const material = new THREE.MeshPhongMaterial({\n      color: 0x00ff88,\n      transparent: true,\n      opacity: 0.9,\n      shininess: 50,\n      specular: 0x44aa66,\n      emissive: 0x002211,\n      emissiveIntensity: 0.1,\n    })\n\n    this.mesh = new THREE.Mesh(geometry, material)\n    this.mesh.castShadow = true\n    this.mesh.receiveShadow = true\n\n    // Set initial position - start underwater with some depth\n    this.mesh.position.set(0, 2, 0) // Start 3 meters below water surface (5 - 2 = 3m depth)\n\n    // Add to scene\n    this.scene.add(this.mesh)\n  }\n\n  /**\n   * Create physics body for collision detection and movement\n   */\n  createPhysicsBody() {\n    this.physicsBody = this.physicsEngine.createSphereBody(\n      this.mesh.position.clone(), // Use the mesh position which is now set to (0, 2, 0)\n      0.7, // Slightly larger radius for collision detection\n      false // Not static - player can move\n    )\n\n    // Add physics body to engine\n    this.physicsEngine.addRigidBody(this.physicsBody)\n  }\n\n  /**\n   * Handle input and update movement vector\n   * @param {Object} inputState - Current input state\n   */\n  handleInput(inputState) {\n    // Reset movement vector\n    this.movementVector.set(0, 0, 0)\n    this.isMoving = false\n\n    // Keyboard input\n    if (inputState.keys) {\n      if (inputState.keys.forward) {\n        this.movementVector.z -= 1\n        this.isMoving = true\n      }\n      if (inputState.keys.backward) {\n        this.movementVector.z += 1\n        this.isMoving = true\n      }\n      if (inputState.keys.left) {\n        this.movementVector.x -= 1\n        this.isMoving = true\n      }\n      if (inputState.keys.right) {\n        this.movementVector.x += 1\n        this.isMoving = true\n      }\n      if (inputState.keys.up) {\n        this.movementVector.y += 1\n        this.isMoving = true\n      }\n      if (inputState.keys.down) {\n        this.movementVector.y -= 1\n        this.isMoving = true\n      }\n    }\n\n    // Touch/mobile input\n    if (inputState.joystick) {\n      this.movementVector.x += inputState.joystick.x\n      this.movementVector.z += inputState.joystick.y\n      if (\n        Math.abs(inputState.joystick.x) > 0.1 ||\n        Math.abs(inputState.joystick.y) > 0.1\n      ) {\n        this.isMoving = true\n      }\n    }\n\n    // Mobile buttons\n    if (inputState.mobileButtons) {\n      if (inputState.mobileButtons.swimUp) {\n        this.movementVector.y += 1\n        this.isMoving = true\n      }\n      if (inputState.mobileButtons.swimDown) {\n        this.movementVector.y -= 1\n        this.isMoving = true\n      }\n    }\n\n    // Normalize movement vector to prevent faster diagonal movement\n    if (this.movementVector.length() > 1) {\n      this.movementVector.normalize()\n    }\n\n    // Apply movement to physics body\n    this.applyMovement()\n  }\n\n  /**\n   * Apply movement forces to the physics body\n   */\n  applyMovement() {\n    if (!this.isMoving) {\n      // Apply stronger drag when not actively moving\n      this.physicsBody.velocity.multiplyScalar(0.9)\n      return\n    }\n\n    // Calculate movement force\n    const force = this.movementVector\n      .clone()\n      .multiplyScalar(this.moveSpeed * 0.016) // Assume ~60fps for consistent feel\n\n    // Add force to velocity\n    this.physicsBody.velocity.add(force)\n\n    // Clamp velocity to max speed\n    if (this.physicsBody.velocity.length() > this.maxVelocity) {\n      this.physicsBody.velocity.normalize().multiplyScalar(this.maxVelocity)\n    }\n\n    // Rotate player to face movement direction (optional visual enhancement)\n    if (this.movementVector.length() > 0.1) {\n      const targetRotation = Math.atan2(\n        this.movementVector.x,\n        this.movementVector.z\n      )\n      this.mesh.rotation.y = THREE.MathUtils.lerp(\n        this.mesh.rotation.y,\n        targetRotation,\n        this.rotationSpeed * 0.016\n      )\n    }\n  }\n\n  /**\n   * Update player state\n   */\n  update() {\n    // Sync mesh position with physics body (don't override physics with floating animation)\n    this.mesh.position.copy(this.physicsBody.position)\n\n    // Add gentle floating animation to visual representation only\n    const time = Date.now() * 0.001\n    const floatingOffset = Math.sin(time * 2) * 0.02\n    this.mesh.position.y += floatingOffset\n\n    // Don't update physics body position from mesh - let physics handle position\n    // The physics body position should be authoritative\n  }\n\n  /**\n   * Handle collisions with other objects\n   * @param {Array} collisions - Array of objects the player collided with\n   */\n  handleCollisions(collisions) {\n    for (const collision of collisions) {\n      // Handle different types of collisions\n      if (collision.type === 'collectible') {\n        this.handleCollectibleCollision(collision)\n      } else if (collision.type === 'obstacle') {\n        this.handleObstacleCollision(collision)\n      } else if (collision.type === 'environment') {\n        this.handleEnvironmentCollision(collision)\n      }\n    }\n  }\n\n  /**\n   * Handle collision with collectible items\n   * @param {Object} collectible - Collectible object\n   */\n  handleCollectibleCollision(collectible) {\n    // Collectibles will be handled by the game manager\n    // This is just for reference and future expansion\n    console.log('Player collected item:', collectible)\n  }\n\n  /**\n   * Handle collision with obstacles\n   * @param {Object} obstacle - Obstacle object\n   */\n  handleObstacleCollision(obstacle) {\n    // Bounce back slightly from obstacles\n    const direction = this.physicsBody.position\n      .clone()\n      .sub(obstacle.position)\n      .normalize()\n\n    this.physicsBody.velocity.add(direction.multiplyScalar(2))\n  }\n\n  /**\n   * Handle collision with environment objects\n   * @param {Object} _envObject - Environment object (unused for now)\n   */\n  handleEnvironmentCollision() {\n    // Environment collisions are handled by physics engine\n    // This can be used for special effects or sounds\n  }\n\n  /**\n   * Get current player position\n   * @returns {THREE.Vector3} Current position\n   */\n  getPosition() {\n    // Return physics body position (authoritative) instead of mesh position (includes floating animation)\n    return this.physicsBody.position.clone()\n  }\n\n  /**\n   * Set player position\n   * @param {THREE.Vector3} position - New position\n   */\n  setPosition(position) {\n    this.mesh.position.copy(position)\n    this.physicsBody.position.copy(position)\n  }\n\n  /**\n   * Get current velocity\n   * @returns {THREE.Vector3} Current velocity\n   */\n  getVelocity() {\n    return this.physicsBody.velocity.clone()\n  }\n\n  /**\n   * Check if player is moving\n   * @returns {boolean} Whether player is currently moving\n   */\n  getIsMoving() {\n    return this.isMoving || this.physicsBody.velocity.length() > 0.1\n  }\n\n  /**\n   * Dispose of player resources\n   */\n  dispose() {\n    // Remove from physics engine\n    this.physicsEngine.removeRigidBody(this.physicsBody)\n\n    // Remove mesh from scene\n    this.scene.remove(this.mesh)\n\n    // Dispose geometry and material\n    this.mesh.geometry.dispose()\n    this.mesh.material.dispose()\n  }\n}\n","/**\n * Ocean Adventure - Main Game Entry Point\n *\n * This is a placeholder implementation showing the basic structure\n * for the 3D underwater platform game. The actual game engine\n * implementation will be developed following the Copilot plan.\n */\n\nimport * as THREE from 'three'\nimport { PhysicsEngine } from './core/Physics.js'\nimport { ParticleSystem } from './core/ParticleSystem.js'\nimport { Player } from './components/Player.js'\n\n// Game configuration\nconst CONFIG = {\n  targetFPS: 60,\n  mobileFPS: 30,\n  canvasId: 'gameCanvas',\n  loadingId: 'loading',\n  uiId: 'ui',\n}\n\nclass OceanAdventure {\n  constructor() {\n    this.scene = null\n    this.camera = null\n    this.renderer = null\n    this.canvas = null\n    this.isLoaded = false\n    this.isMobile = this.detectMobile()\n\n    // Core systems\n    this.physicsEngine = null\n    this.particleSystem = null\n    this.player = null\n    this.environmentObjects = []\n\n    // Game state\n    this.starCount = 0\n    this.levelNumber = 1\n\n    // Input state\n    this.inputState = {\n      keys: {\n        forward: false,\n        backward: false,\n        left: false,\n        right: false,\n        up: false,\n        down: false,\n      },\n      joystick: { x: 0, y: 0 },\n      mobileButtons: { swimUp: false, swimDown: false },\n    }\n\n    // Timing\n    this.lastTime = 0\n\n    console.log('üåä Ocean Adventure - Initializing...')\n  }\n\n  async initialize() {\n    try {\n      this.setupCanvas()\n      this.setupRenderer()\n      this.setupScene()\n      this.setupCamera()\n      this.setupLights()\n\n      // Initialize core systems\n      this.initializePhysics()\n      this.initializeParticleSystem()\n\n      // Create game objects\n      this.createUnderwaterEnvironment()\n      this.createPlayer()\n      this.createSampleStars()\n\n      this.setupEventListeners()\n\n      // Hide loading screen and show UI\n      this.hideLoading()\n      this.showUI()\n\n      // Start game loop\n      this.startGameLoop()\n\n      this.isLoaded = true\n      console.log('üéÆ Ocean Adventure - Ready to play!')\n    } catch (error) {\n      console.error('‚ùå Failed to initialize game:', error)\n    }\n  }\n\n  setupCanvas() {\n    this.canvas = document.getElementById(CONFIG.canvasId)\n    if (!this.canvas) {\n      throw new Error('Game canvas not found')\n    }\n  }\n\n  setupRenderer() {\n    try {\n      this.renderer = new THREE.WebGLRenderer({\n        canvas: this.canvas,\n        antialias: !this.isMobile, // Disable antialiasing on mobile for performance\n        alpha: false,\n        powerPreference: this.isMobile ? 'low-power' : 'high-performance',\n        failIfMajorPerformanceCaveat: false, // Allow fallback rendering\n        preserveDrawingBuffer: false, // Better performance\n        premultipliedAlpha: false,\n        stencil: false, // Reduce memory usage\n      })\n\n      this.renderer.setSize(window.innerWidth, window.innerHeight)\n      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n      this.renderer.setClearColor(0x001122, 1) // Deep ocean blue\n\n      // Enable shadows with mobile-optimized settings\n      this.renderer.shadowMap.enabled = true\n      this.renderer.shadowMap.type = this.isMobile\n        ? THREE.BasicShadowMap // Faster shadow type for mobile\n        : THREE.PCFSoftShadowMap // Better quality for desktop\n\n      // Enhanced WebGL settings for better lighting\n      this.renderer.physicallyCorrectLights = false // Better performance\n      this.renderer.outputEncoding = THREE.sRGBEncoding\n      this.renderer.toneMapping = THREE.ACESFilmicToneMapping\n      this.renderer.toneMappingExposure = 1.0\n\n      // Validate WebGL context\n      const gl = this.renderer.getContext()\n      if (!gl) {\n        throw new Error('Failed to get WebGL context')\n      }\n\n      // Add error handling for WebGL\n      gl.getExtension('WEBGL_lose_context')\n\n      console.log('‚úÖ WebGL Renderer initialized with enhanced lighting')\n    } catch (error) {\n      console.error('‚ùå Failed to setup renderer:', error)\n      throw error\n    }\n  }\n\n  setupScene() {\n    this.scene = new THREE.Scene()\n  }\n\n  /**\n   * Initialize physics engine\n   */\n  initializePhysics() {\n    this.physicsEngine = new PhysicsEngine()\n    console.log('‚ö° Physics engine initialized')\n  }\n\n  /**\n   * Initialize particle system\n   */\n  initializeParticleSystem() {\n    this.particleSystem = new ParticleSystem(this.scene, 500) // Reduced for mobile performance\n    console.log('‚ú® Particle system initialized')\n  }\n\n  setupCamera() {\n    this.camera = new THREE.PerspectiveCamera(\n      75, // Field of view\n      window.innerWidth / window.innerHeight, // Aspect ratio\n      0.1, // Near clipping plane\n      1000 // Far clipping plane\n    )\n\n    // Position camera behind and above the player\n    this.camera.position.set(0, 5, 10)\n    this.camera.lookAt(0, 0, 0)\n  }\n\n  setupLights() {\n    // Enhanced underwater ambient lighting\n    const ambientLight = new THREE.AmbientLight(0x336699, 0.6)\n    this.scene.add(ambientLight)\n\n    // Primary directional light simulating filtered sunlight from above\n    const directionalLight = new THREE.DirectionalLight(0x87ceeb, 1.2)\n    directionalLight.position.set(0, 50, 10)\n\n    // Enable shadows with optimized settings for mobile compatibility\n    if (this.renderer.shadowMap.enabled) {\n      directionalLight.castShadow = true\n      // Use smaller shadow map sizes on mobile for better performance\n      const shadowMapSize = this.isMobile ? 512 : 1024\n      directionalLight.shadow.mapSize.width = shadowMapSize\n      directionalLight.shadow.mapSize.height = shadowMapSize\n      directionalLight.shadow.camera.near = 0.5\n      directionalLight.shadow.camera.far = 500\n      directionalLight.shadow.camera.left = -50\n      directionalLight.shadow.camera.right = 50\n      directionalLight.shadow.camera.top = 50\n      directionalLight.shadow.camera.bottom = -50\n      // Use less expensive shadow map type on mobile\n      if (this.isMobile) {\n        directionalLight.shadow.bias = -0.0005\n      }\n    }\n\n    this.scene.add(directionalLight)\n\n    // Add volumetric underwater lighting with point lights for better WebGL effects\n    this.addUnderwaterVolumetricLights()\n\n    // Add subtle rim lighting to enhance object definition\n    const rimLight = new THREE.DirectionalLight(0x4a9eff, 0.4)\n    rimLight.position.set(-20, 10, -20)\n    this.scene.add(rimLight)\n  }\n\n  addUnderwaterVolumetricLights() {\n    // Create multiple point lights for underwater caustics effect\n    const lightColors = [0x4a9eff, 0x87ceeb, 0x6495ed, 0x00bfff]\n    const lightCount = this.isMobile ? 3 : 5 // Fewer lights on mobile\n\n    for (let i = 0; i < lightCount; i++) {\n      const pointLight = new THREE.PointLight(\n        lightColors[i % lightColors.length],\n        this.isMobile ? 0.6 : 0.8, // Reduced intensity on mobile\n        30, // Distance\n        2 // Decay\n      )\n\n      // Position lights in a scattered pattern above the scene\n      const angle = (i / lightCount) * Math.PI * 2\n      const radius = 15 + Math.random() * 10\n      pointLight.position.set(\n        Math.cos(angle) * radius,\n        8 + Math.random() * 5, // Varying heights\n        Math.sin(angle) * radius\n      )\n\n      // Store animation properties\n      pointLight.userData = {\n        originalPosition: pointLight.position.clone(),\n        animationOffset: Math.random() * Math.PI * 2,\n        animationSpeed: 0.5 + Math.random() * 0.5,\n        animationRadius: 2 + Math.random() * 3,\n      }\n\n      this.scene.add(pointLight)\n\n      // Store reference for animation\n      if (!this.volumetricLights) {\n        this.volumetricLights = []\n      }\n      this.volumetricLights.push(pointLight)\n    }\n  }\n\n  createUnderwaterEnvironment() {\n    // Create ocean floor with enhanced material\n    const floorGeometry = new THREE.PlaneGeometry(100, 100)\n    const floorMaterial = new THREE.MeshPhongMaterial({\n      color: 0x8b4513,\n      shininess: 30,\n      specular: 0x222222,\n    })\n    const floor = new THREE.Mesh(floorGeometry, floorMaterial)\n    floor.rotation.x = -Math.PI / 2\n    floor.position.y = -5\n    floor.receiveShadow = true\n    this.scene.add(floor)\n\n    // Create physics body for floor\n    const floorPhysicsBody = this.physicsEngine.createBoxBody(\n      new THREE.Vector3(0, -5, 0),\n      new THREE.Vector3(100, 0.1, 100),\n      true // Static\n    )\n    floorPhysicsBody.type = 'environment'\n    this.physicsEngine.addRigidBody(floorPhysicsBody)\n\n    // Add coral/rocks with enhanced materials and lighting\n    for (let i = 0; i < 10; i++) {\n      const radius = 0.5 + Math.random() * 1.5\n      const geometry = new THREE.SphereGeometry(radius)\n\n      // Use MeshPhongMaterial for better lighting on all platforms\n      const hue = Math.random() * 0.3\n      const material = new THREE.MeshPhongMaterial({\n        color: new THREE.Color().setHSL(hue, 0.7, 0.5),\n        shininess: 60 + Math.random() * 40,\n        specular: new THREE.Color().setHSL(hue, 0.3, 0.8),\n        // Add slight transparency for underwater effect\n        transparent: true,\n        opacity: 0.9,\n      })\n\n      const coral = new THREE.Mesh(geometry, material)\n\n      const position = new THREE.Vector3(\n        (Math.random() - 0.5) * 80,\n        -4 + Math.random() * 2,\n        (Math.random() - 0.5) * 80\n      )\n      coral.position.copy(position)\n      coral.castShadow = true\n      coral.receiveShadow = true\n      this.scene.add(coral)\n\n      // Add physics body for collision\n      const coralPhysicsBody = this.physicsEngine.createSphereBody(\n        position,\n        radius * 1.2, // Slightly larger for collision detection\n        true // Static\n      )\n      coralPhysicsBody.type = 'environment'\n      coralPhysicsBody.mesh = coral // Reference to visual representation\n      this.physicsEngine.addRigidBody(coralPhysicsBody)\n      this.environmentObjects.push({\n        mesh: coral,\n        physicsBody: coralPhysicsBody,\n      })\n    }\n  }\n\n  createPlayer() {\n    // Create enhanced player with physics\n    this.player = new Player(this.scene, this.physicsEngine)\n    console.log('üèä Player created with physics')\n  }\n\n  createSampleStars() {\n    this.stars = []\n\n    // Create glowing star collectibles with enhanced materials\n    for (let i = 0; i < 5; i++) {\n      const starGeometry = new THREE.SphereGeometry(0.3)\n\n      // Use MeshPhongMaterial for better lighting effects\n      const starMaterial = new THREE.MeshPhongMaterial({\n        color: 0xffd700,\n        emissive: 0xffd700,\n        emissiveIntensity: 0.4,\n        shininess: 100,\n        specular: 0xffffff,\n        transparent: true,\n        opacity: 0.95,\n      })\n\n      const star = new THREE.Mesh(starGeometry, starMaterial)\n      const position = new THREE.Vector3(\n        (Math.random() - 0.5) * 20,\n        Math.random() * 8 - 2,\n        (Math.random() - 0.5) * 20\n      )\n      star.position.copy(position)\n      star.castShadow = true\n\n      // Add physics body for collision detection\n      const starPhysicsBody = this.physicsEngine.createSphereBody(\n        position,\n        0.5, // Slightly larger for easier collection\n        true // Static - stars don't move\n      )\n      starPhysicsBody.type = 'collectible'\n      starPhysicsBody.mesh = star\n      starPhysicsBody.collected = false\n      this.physicsEngine.addRigidBody(starPhysicsBody)\n\n      // Add simple rotation animation and floating effect\n      star.userData = {\n        rotationSpeed: 0.02 + Math.random() * 0.02,\n        floatSpeed: 0.01 + Math.random() * 0.01,\n        floatOffset: Math.random() * Math.PI * 2,\n        originalY: position.y,\n        physicsBody: starPhysicsBody,\n      }\n\n      this.stars.push({ mesh: star, physicsBody: starPhysicsBody })\n      this.scene.add(star)\n    }\n  }\n\n  setupEventListeners() {\n    // Handle window resize\n    window.addEventListener('resize', () => this.onWindowResize())\n\n    // Enhanced input handling\n    window.addEventListener('keydown', event => this.onKeyDown(event))\n    window.addEventListener('keyup', event => this.onKeyUp(event))\n\n    // Touch controls for mobile\n    if (this.isMobile) {\n      this.setupTouchControls()\n    }\n\n    // Settings modal functionality\n    this.setupSettingsModal()\n  }\n\n  onKeyDown(event) {\n    switch (event.code) {\n      case 'ArrowUp':\n      case 'KeyW':\n        this.inputState.keys.forward = true\n        break\n      case 'ArrowDown':\n      case 'KeyS':\n        this.inputState.keys.backward = true\n        break\n      case 'ArrowLeft':\n      case 'KeyA':\n        this.inputState.keys.left = true\n        break\n      case 'ArrowRight':\n      case 'KeyD':\n        this.inputState.keys.right = true\n        break\n      case 'Space':\n        this.inputState.keys.up = true\n        event.preventDefault()\n        break\n      case 'ShiftLeft':\n        this.inputState.keys.down = true\n        break\n    }\n  }\n\n  onKeyUp(event) {\n    switch (event.code) {\n      case 'ArrowUp':\n      case 'KeyW':\n        this.inputState.keys.forward = false\n        break\n      case 'ArrowDown':\n      case 'KeyS':\n        this.inputState.keys.backward = false\n        break\n      case 'ArrowLeft':\n      case 'KeyA':\n        this.inputState.keys.left = false\n        break\n      case 'ArrowRight':\n      case 'KeyD':\n        this.inputState.keys.right = false\n        break\n      case 'Space':\n        this.inputState.keys.up = false\n        break\n      case 'ShiftLeft':\n        this.inputState.keys.down = false\n        break\n    }\n  }\n\n  setupTouchControls() {\n    // Setup virtual joystick\n    this.setupVirtualJoystick()\n\n    // Setup mobile action buttons\n    this.setupMobileButtons()\n\n    // Touch control state for general canvas interactions\n    this.touchState = {\n      startX: 0,\n      startY: 0,\n      currentX: 0,\n      currentY: 0,\n      isActive: false,\n    }\n\n    // General canvas touch events (for swipe gestures)\n    this.canvas.addEventListener('touchstart', event => {\n      event.preventDefault()\n      if (event.touches.length > 0) {\n        const touch = event.touches[0]\n        this.touchState.startX = touch.clientX\n        this.touchState.startY = touch.clientY\n        this.touchState.currentX = touch.clientX\n        this.touchState.currentY = touch.clientY\n        this.touchState.isActive = true\n      }\n    })\n\n    this.canvas.addEventListener('touchmove', event => {\n      event.preventDefault()\n      if (event.touches.length > 0 && this.touchState.isActive) {\n        const touch = event.touches[0]\n        this.touchState.currentX = touch.clientX\n        this.touchState.currentY = touch.clientY\n\n        // Calculate movement delta for swipe gestures\n        const deltaX = this.touchState.currentX - this.touchState.startX\n        const deltaY = this.touchState.currentY - this.touchState.startY\n\n        // Apply gentle swipe-based movement (subtle effect)\n        const moveSpeed = 0.05\n        const sensitivity = 3\n\n        if (Math.abs(deltaX) > 20) {\n          this.player.position.x += (deltaX / sensitivity) * moveSpeed * 0.01\n        }\n\n        if (Math.abs(deltaY) > 20) {\n          this.player.position.z += (deltaY / sensitivity) * moveSpeed * 0.01\n        }\n\n        this.updateCamera()\n      }\n    })\n\n    this.canvas.addEventListener('touchend', event => {\n      event.preventDefault()\n      this.touchState.isActive = false\n    })\n\n    this.canvas.addEventListener('touchcancel', event => {\n      event.preventDefault()\n      this.touchState.isActive = false\n    })\n  }\n\n  setupVirtualJoystick() {\n    const joystick = document.getElementById('virtualJoystick')\n    const knob = document.getElementById('joystickKnob')\n\n    if (!joystick || !knob) {\n      return\n    }\n\n    const joystickState = {\n      isActive: false,\n      centerX: 0,\n      centerY: 0,\n      currentX: 0,\n      currentY: 0,\n    }\n\n    joystick.addEventListener('touchstart', event => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      if (event.touches.length > 0) {\n        const touch = event.touches[0]\n        const rect = joystick.getBoundingClientRect()\n\n        joystickState.isActive = true\n        joystickState.centerX = rect.left + rect.width / 2\n        joystickState.centerY = rect.top + rect.height / 2\n        joystickState.currentX = touch.clientX\n        joystickState.currentY = touch.clientY\n\n        // Visual feedback - highlight joystick when active\n        joystick.style.borderColor = 'rgba(255, 255, 255, 0.6)'\n        joystick.style.background = 'rgba(0, 17, 34, 0.7)'\n\n        this.updateJoystickKnob(knob, joystickState, rect)\n      }\n    })\n\n    joystick.addEventListener('touchmove', event => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      if (event.touches.length > 0 && joystickState.isActive) {\n        const touch = event.touches[0]\n        const rect = joystick.getBoundingClientRect()\n\n        joystickState.currentX = touch.clientX\n        joystickState.currentY = touch.clientY\n\n        // Calculate movement vector\n        const deltaX = joystickState.currentX - joystickState.centerX\n        const deltaY = joystickState.currentY - joystickState.centerY\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n        const maxDistance = rect.width / 2 - 20\n\n        // Normalize and apply movement\n        if (distance > 5) {\n          const normalizedX = deltaX / maxDistance\n          const normalizedY = deltaY / maxDistance\n\n          // Update input state with improved sensitivity for mobile\n          this.inputState.joystick.x = Math.max(\n            -1,\n            Math.min(1, normalizedX * 1.2)\n          )\n          this.inputState.joystick.y = Math.max(\n            -1,\n            Math.min(1, normalizedY * 1.2)\n          )\n        } else {\n          this.inputState.joystick.x = 0\n          this.inputState.joystick.y = 0\n        }\n\n        this.updateJoystickKnob(knob, joystickState, rect)\n      }\n    })\n\n    joystick.addEventListener('touchend', event => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      joystickState.isActive = false\n      this.inputState.joystick.x = 0\n      this.inputState.joystick.y = 0\n\n      // Reset visual feedback\n      joystick.style.borderColor = 'rgba(255, 255, 255, 0.3)'\n      joystick.style.background = 'rgba(0, 17, 34, 0.5)'\n      knob.style.transform = 'translate(-50%, -50%)'\n    })\n\n    joystick.addEventListener('touchcancel', event => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      joystickState.isActive = false\n      this.inputState.joystick.x = 0\n      this.inputState.joystick.y = 0\n\n      // Reset visual feedback\n      joystick.style.borderColor = 'rgba(255, 255, 255, 0.3)'\n      joystick.style.background = 'rgba(0, 17, 34, 0.5)'\n      knob.style.transform = 'translate(-50%, -50%)'\n    })\n  }\n\n  updateJoystickKnob(knob, joystickState, rect) {\n    const deltaX = joystickState.currentX - joystickState.centerX\n    const deltaY = joystickState.currentY - joystickState.centerY\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n    const maxDistance = rect.width / 2 - 20\n\n    if (distance <= maxDistance) {\n      knob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`\n    } else {\n      const angle = Math.atan2(deltaY, deltaX)\n      const x = Math.cos(angle) * maxDistance\n      const y = Math.sin(angle) * maxDistance\n      knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`\n    }\n  }\n\n  setupMobileButtons() {\n    const swimUpBtn = document.getElementById('swimUpBtn')\n    const swimDownBtn = document.getElementById('swimDownBtn')\n\n    if (swimUpBtn) {\n      // Add more responsive event handling\n      swimUpBtn.addEventListener('touchstart', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimUp = true\n        swimUpBtn.style.background = 'rgba(255, 255, 255, 0.4)'\n      })\n\n      swimUpBtn.addEventListener('touchend', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimUp = false\n        swimUpBtn.style.background = 'rgba(0, 17, 34, 0.6)'\n      })\n\n      swimUpBtn.addEventListener('touchcancel', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimUp = false\n        swimUpBtn.style.background = 'rgba(0, 17, 34, 0.6)'\n      })\n    }\n\n    if (swimDownBtn) {\n      // Add more responsive event handling\n      swimDownBtn.addEventListener('touchstart', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimDown = true\n        swimDownBtn.style.background = 'rgba(255, 255, 255, 0.4)'\n      })\n\n      swimDownBtn.addEventListener('touchend', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimDown = false\n        swimDownBtn.style.background = 'rgba(0, 17, 34, 0.6)'\n      })\n\n      swimDownBtn.addEventListener('touchcancel', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimDown = false\n        swimDownBtn.style.background = 'rgba(0, 17, 34, 0.6)'\n      })\n    }\n  }\n\n  setupSettingsModal() {\n    const settingsButton = document.getElementById('settingsButton')\n    const settingsModal = document.getElementById('settingsModal')\n    const closeSettings = document.getElementById('closeSettings')\n\n    if (settingsButton && settingsModal && closeSettings) {\n      // Open settings\n      const openSettings = event => {\n        if (event) {\n          event.preventDefault()\n          event.stopPropagation()\n        }\n        settingsModal.classList.remove('hidden')\n        // Prevent body scrolling when modal is open\n        document.body.style.overflow = 'hidden'\n      }\n\n      // Close settings\n      const closeModal = event => {\n        if (event) {\n          event.preventDefault()\n          event.stopPropagation()\n        }\n        settingsModal.classList.add('hidden')\n        // Restore body scrolling\n        document.body.style.overflow = ''\n      }\n\n      // Simple event handling - click events work on both desktop and mobile\n      settingsButton.addEventListener('click', openSettings)\n      closeSettings.addEventListener('click', closeModal)\n\n      // Close on background click - works on both desktop and mobile\n      settingsModal.addEventListener('click', event => {\n        if (event.target === settingsModal) {\n          closeModal(event)\n        }\n      })\n\n      // Close on escape key\n      document.addEventListener('keydown', event => {\n        if (\n          event.key === 'Escape' &&\n          !settingsModal.classList.contains('hidden')\n        ) {\n          closeModal()\n        }\n      })\n    }\n  }\n\n  onWindowResize() {\n    this.camera.aspect = window.innerWidth / window.innerHeight\n    this.camera.updateProjectionMatrix()\n    this.renderer.setSize(window.innerWidth, window.innerHeight)\n  }\n\n  updateCamera() {\n    // Enhanced camera follow logic\n    const playerPosition = this.player.getPosition()\n    const offset = new THREE.Vector3(0, 5, 10)\n    const targetPosition = playerPosition.clone().add(offset)\n\n    this.camera.position.lerp(targetPosition, 0.1)\n    this.camera.lookAt(playerPosition)\n  }\n\n  startGameLoop() {\n    const animate = currentTime => {\n      requestAnimationFrame(animate)\n\n      // Calculate delta time\n      const deltaTime =\n        this.lastTime > 0 ? (currentTime - this.lastTime) / 1000 : 0.016\n      this.lastTime = currentTime\n\n      this.update(deltaTime)\n      this.render()\n    }\n    animate(0)\n  }\n\n  update(deltaTime) {\n    if (!this.isLoaded) {\n      return\n    }\n\n    // Clamp delta time to prevent large jumps\n    deltaTime = Math.min(deltaTime, 0.033) // Max 30fps equivalent\n\n    // Update physics engine\n    this.physicsEngine.update(deltaTime)\n\n    // Update player with input\n    this.player.handleInput(this.inputState)\n    this.player.update()\n\n    // Update particle system\n    this.particleSystem.update(deltaTime)\n\n    // Update camera\n    this.updateCamera()\n\n    // Update UI (including depth meter)\n    this.updateUI()\n\n    // Animate stars with floating and pulsing effects\n    this.stars.forEach(starData => {\n      const star = starData.mesh\n      const userData = star.userData\n\n      // Rotation animation\n      star.rotation.y += userData.rotationSpeed\n      star.rotation.x += userData.rotationSpeed * 0.5\n\n      // Floating animation\n      const time = Date.now() * 0.001\n      const floatY =\n        userData.originalY +\n        Math.sin(time * userData.floatSpeed + userData.floatOffset) * 0.3\n      star.position.y = floatY\n\n      // Pulsing emissive effect\n      const pulseFactor = 0.3 + Math.sin(time * 2 + userData.floatOffset) * 0.1\n      star.material.emissiveIntensity = pulseFactor\n    })\n\n    // Animate volumetric lights for underwater caustics effect\n    if (this.volumetricLights) {\n      const time = Date.now() * 0.001\n      this.volumetricLights.forEach(light => {\n        const userData = light.userData\n        const animationTime =\n          time * userData.animationSpeed + userData.animationOffset\n\n        // Create gentle swaying motion\n        const offsetX = Math.sin(animationTime) * userData.animationRadius\n        const offsetZ = Math.cos(animationTime * 1.3) * userData.animationRadius\n        const offsetY = Math.sin(animationTime * 0.7) * 1\n\n        light.position.x = userData.originalPosition.x + offsetX\n        light.position.y = userData.originalPosition.y + offsetY\n        light.position.z = userData.originalPosition.z + offsetZ\n\n        // Subtle intensity variation for flickering water caustics\n        const intensityVariation = 0.8 + Math.sin(animationTime * 3) * 0.2\n        light.intensity = (this.isMobile ? 0.6 : 0.8) * intensityVariation\n      })\n    }\n\n    // Check star collection using collision detection\n    this.checkStarCollection()\n  }\n\n  checkStarCollection() {\n    // Get player collisions from physics engine\n    const playerCollisions = this.physicsEngine.collisionSystem.checkCollisions(\n      this.player.physicsBody\n    )\n\n    for (const collision of playerCollisions) {\n      if (collision.type === 'collectible' && !collision.collected) {\n        // Collect star\n        collision.collected = true\n\n        // Find and remove the star from scene and physics\n        const starData = this.stars.find(s => s.physicsBody === collision)\n        if (starData) {\n          // Remove from scene\n          this.scene.remove(starData.mesh)\n\n          // Remove from physics\n          this.physicsEngine.removeRigidBody(starData.physicsBody)\n\n          // Remove from stars array\n          const index = this.stars.indexOf(starData)\n          if (index !== -1) {\n            this.stars.splice(index, 1)\n          }\n\n          // Update game state\n          this.starCount++\n          this.updateUI()\n\n          // Create collection effect\n          this.particleSystem.createBurst(starData.mesh.position, {\n            count: 15,\n            life: 1.5,\n            velocity: new THREE.Vector3(0, 2, 0),\n            velocityVariation: new THREE.Vector3(3, 3, 3),\n            color: new THREE.Color(0xffd700),\n            size: { min: 3, max: 8 },\n          })\n\n          console.log(`‚≠ê Star collected! Total: ${this.starCount}`)\n\n          // Check if level is complete\n          if (this.stars.length === 0) {\n            this.levelComplete()\n          }\n        }\n      }\n    }\n  }\n\n  levelComplete() {\n    console.log('üéâ Level Complete!')\n    this.levelNumber++\n    // Reset level with new stars\n    this.createSampleStars()\n    this.updateUI()\n  }\n\n  updateUI() {\n    document.getElementById('starCount').textContent = this.starCount\n    document.getElementById('levelNumber').textContent = this.levelNumber\n\n    // Update depth meter based on player Y position\n    if (this.player) {\n      const playerPosition = this.player.getPosition()\n      // Water surface is at Y=5, so depth = surface level - current Y position\n      const waterSurface = 5.0\n      const depth = Math.max(0, waterSurface - playerPosition.y)\n      document.getElementById('depthMeter').textContent = depth.toFixed(1)\n    }\n  }\n\n  render() {\n    try {\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    } catch (error) {\n      // Silently handle WebGL render errors to prevent spam\n      if (this.webglErrorCount < 5) {\n        console.warn('WebGL render error:', error)\n        this.webglErrorCount = (this.webglErrorCount || 0) + 1\n      }\n    }\n  }\n\n  hideLoading() {\n    const loadingElement = document.getElementById(CONFIG.loadingId)\n    if (loadingElement) {\n      loadingElement.classList.add('hidden')\n    }\n  }\n\n  showUI() {\n    const uiElement = document.getElementById(CONFIG.uiId)\n    if (uiElement) {\n      uiElement.classList.remove('hidden')\n    }\n    this.updateUI()\n  }\n\n  detectMobile() {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    )\n  }\n}\n\n// Initialize the game when the page loads\nwindow.addEventListener('DOMContentLoaded', async () => {\n  const game = new OceanAdventure()\n  await game.initialize()\n})\n\n// Handle WebGL context loss\nwindow.addEventListener('webglcontextlost', event => {\n  event.preventDefault()\n  console.warn('WebGL context lost')\n})\n\nwindow.addEventListener('webglcontextrestored', () => {\n  console.log('WebGL context restored')\n  // Reinitialize game here if needed\n})\n"],"names":["CollisionSystem","constructor","this","colliders","staticColliders","addCollider","collider","isStatic","push","removeCollider","index","indexOf","splice","checkCollision","objectA","objectB","collisionType","checkSphereCollision","checkAABBCollision","checkSphereAABBCollision","sphereA","sphereB","position","distanceTo","radius","boxA","boxB","minA","clone","sub","size","multiplyScalar","maxA","add","minB","maxB","x","y","z","sphere","box","boxMin","boxMax","closestPoint","THREE.Vector3","Math","max","min","checkCollisions","object","collisions","UnderwaterPhysics","buoyancyForce","dragCoefficient","currentDirection","currentStrength","applyBuoyancy","body","deltaTime","buoyancy","velocity","applyDrag","applyCurrent","currentForce","applyUnderwaterEffects","PhysicsEngine","gravity","waterDensity","collisionSystem","underwaterPhysics","rigidBodies","isUnderwater","addRigidBody","removeRigidBody","update","updateBody","previousPosition","gravityForce","velocityDelta","length","resolveCollisions","copy","onCollision","collisionPairs","i","bodyA","bodyB","createSphereBody","createBoxBody","Particle","life","color","maxLife","alpha","active","reset","ParticleSystem","scene","maxParticles","particles","emitters","initializeParticlePool","createParticleRenderSystem","createUnderwaterEmitters","particle","THREE.Color","geometry","THREE.BufferGeometry","positions","Float32Array","colors","sizes","alphas","setAttribute","THREE.BufferAttribute","material","THREE.ShaderMaterial","uniforms","time","value","pointTexture","createParticleTexture","vertexShader","fragmentShader","transparent","blending","THREE.AdditiveBlending","depthWrite","points","THREE.Points","canvas","document","createElement","width","height","context","getContext","gradient","createRadialGradient","addColorStop","fillStyle","fillRect","texture","THREE.Texture","needsUpdate","addEmitter","type","rate","velocityVariation","colorVariation","area","emitterConfig","emitter","accumulator","emitParticle","find","p","random","offsetHSL","createBurst","config","count","burstVelocity","particleSize","emissionInterval","activeCount","index3","r","g","b","attributes","setDrawRange","setEmitterActive","e","clear","dispose","remove","Player","physicsEngine","moveSpeed","rotationSpeed","maxVelocity","movementVector","isMoving","createPlayerMesh","createPhysicsBody","physicsBody","handleCollisions","THREE.CapsuleGeometry","THREE.MeshPhongMaterial","opacity","shininess","specular","emissive","emissiveIntensity","mesh","THREE.Mesh","castShadow","receiveShadow","set","handleInput","inputState","keys","forward","backward","left","right","up","down","joystick","abs","mobileButtons","swimUp","swimDown","normalize","applyMovement","force","targetRotation","atan2","rotation","THREE.MathUtils","lerp","Date","now","floatingOffset","sin","collision","handleCollectibleCollision","handleObstacleCollision","handleEnvironmentCollision","collectible","console","log","obstacle","direction","getPosition","setPosition","getVelocity","getIsMoving","CONFIG","OceanAdventure","camera","renderer","isLoaded","isMobile","detectMobile","particleSystem","player","environmentObjects","starCount","levelNumber","lastTime","initialize","setupCanvas","setupRenderer","setupScene","setupCamera","setupLights","initializePhysics","initializeParticleSystem","createUnderwaterEnvironment","createPlayer","createSampleStars","setupEventListeners","hideLoading","showUI","startGameLoop","error","getElementById","Error","THREE.WebGLRenderer","antialias","powerPreference","failIfMajorPerformanceCaveat","preserveDrawingBuffer","premultipliedAlpha","stencil","setSize","window","innerWidth","innerHeight","setPixelRatio","devicePixelRatio","setClearColor","shadowMap","enabled","THREE.BasicShadowMap","THREE.PCFSoftShadowMap","physicallyCorrectLights","outputEncoding","THREE.sRGBEncoding","toneMapping","THREE.ACESFilmicToneMapping","toneMappingExposure","gl","getExtension","THREE.Scene","THREE.PerspectiveCamera","lookAt","ambientLight","THREE.AmbientLight","directionalLight","THREE.DirectionalLight","shadowMapSize","shadow","mapSize","near","far","top","bottom","bias","addUnderwaterVolumetricLights","rimLight","lightColors","lightCount","pointLight","THREE.PointLight","angle","PI","cos","userData","originalPosition","animationOffset","animationSpeed","animationRadius","volumetricLights","floorGeometry","THREE.PlaneGeometry","floorMaterial","floor","floorPhysicsBody","THREE.SphereGeometry","hue","setHSL","coral","coralPhysicsBody","stars","starGeometry","starMaterial","star","starPhysicsBody","collected","floatSpeed","floatOffset","originalY","addEventListener","onWindowResize","event","onKeyDown","onKeyUp","setupTouchControls","setupSettingsModal","code","preventDefault","setupVirtualJoystick","setupMobileButtons","touchState","startX","startY","currentX","currentY","isActive","touches","touch","clientX","clientY","deltaX","deltaY","sensitivity","updateCamera","knob","joystickState","centerX","centerY","stopPropagation","rect","getBoundingClientRect","style","borderColor","background","updateJoystickKnob","distance","sqrt","maxDistance","normalizedX","normalizedY","transform","swimUpBtn","swimDownBtn","settingsButton","settingsModal","closeSettings","openSettings","classList","overflow","closeModal","target","key","contains","aspect","updateProjectionMatrix","playerPosition","offset","targetPosition","animate","currentTime","requestAnimationFrame","render","updateUI","forEach","starData","floatY","pulseFactor","light","animationTime","offsetX","offsetZ","offsetY","intensityVariation","intensity","checkStarCollection","playerCollisions","s","levelComplete","textContent","waterSurface","depth","toFixed","webglErrorCount","warn","loadingElement","uiElement","test","navigator","userAgent","async","game"],"mappings":"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"}