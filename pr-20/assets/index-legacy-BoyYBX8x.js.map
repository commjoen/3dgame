{"version":3,"file":"index-legacy-BoyYBX8x.js","sources":["../../src/core/Physics.js","../../src/core/ParticleSystem.js","../../src/components/Player.js","../../src/main.js"],"sourcesContent":["/**\n * Physics Engine for Ocean Adventure\n *\n * Implements collision detection and underwater physics simulation\n * including buoyancy, drag, and environmental forces.\n */\n\nimport * as THREE from 'three'\n\n/**\n * Collision system supporting AABB and sphere-based collision detection\n */\nexport class CollisionSystem {\n  constructor() {\n    this.colliders = []\n    this.staticColliders = []\n  }\n\n  /**\n   * Add a collider to the system\n   * @param {Object} collider - Collider object with geometry and position\n   * @param {boolean} isStatic - Whether the collider is static (doesn't move)\n   */\n  addCollider(collider, isStatic = false) {\n    const list = isStatic ? this.staticColliders : this.colliders\n    list.push(collider)\n  }\n\n  /**\n   * Remove a collider from the system\n   * @param {Object} collider - Collider to remove\n   */\n  removeCollider(collider) {\n    let index = this.colliders.indexOf(collider)\n    if (index !== -1) {\n      this.colliders.splice(index, 1)\n      return\n    }\n\n    index = this.staticColliders.indexOf(collider)\n    if (index !== -1) {\n      this.staticColliders.splice(index, 1)\n    }\n  }\n\n  /**\n   * Check for collisions between two objects\n   * @param {Object} objectA - First object with position and geometry\n   * @param {Object} objectB - Second object with position and geometry\n   * @returns {boolean} Whether objects are colliding\n   */\n  checkCollision(objectA, objectB) {\n    // Sphere-sphere collision detection\n    if (\n      objectA.collisionType === 'sphere' &&\n      objectB.collisionType === 'sphere'\n    ) {\n      return this.checkSphereCollision(objectA, objectB)\n    }\n\n    // AABB-AABB collision detection\n    if (objectA.collisionType === 'box' && objectB.collisionType === 'box') {\n      return this.checkAABBCollision(objectA, objectB)\n    }\n\n    // Sphere-AABB collision detection\n    if (\n      (objectA.collisionType === 'sphere' && objectB.collisionType === 'box') ||\n      (objectA.collisionType === 'box' && objectB.collisionType === 'sphere')\n    ) {\n      return this.checkSphereAABBCollision(objectA, objectB)\n    }\n\n    return false\n  }\n\n  /**\n   * Check sphere-sphere collision\n   * @param {Object} sphereA - First sphere\n   * @param {Object} sphereB - Second sphere\n   * @returns {boolean} Whether spheres are colliding\n   */\n  checkSphereCollision(sphereA, sphereB) {\n    const distance = sphereA.position.distanceTo(sphereB.position)\n    const radiusSum = sphereA.radius + sphereB.radius\n    return distance <= radiusSum\n  }\n\n  /**\n   * Check AABB-AABB collision\n   * @param {Object} boxA - First box\n   * @param {Object} boxB - Second box\n   * @returns {boolean} Whether boxes are colliding\n   */\n  checkAABBCollision(boxA, boxB) {\n    const minA = boxA.position\n      .clone()\n      .sub(boxA.size.clone().multiplyScalar(0.5))\n    const maxA = boxA.position\n      .clone()\n      .add(boxA.size.clone().multiplyScalar(0.5))\n    const minB = boxB.position\n      .clone()\n      .sub(boxB.size.clone().multiplyScalar(0.5))\n    const maxB = boxB.position\n      .clone()\n      .add(boxB.size.clone().multiplyScalar(0.5))\n\n    return (\n      minA.x <= maxB.x &&\n      maxA.x >= minB.x &&\n      minA.y <= maxB.y &&\n      maxA.y >= minB.y &&\n      minA.z <= maxB.z &&\n      maxA.z >= minB.z\n    )\n  }\n\n  /**\n   * Check sphere-AABB collision\n   * @param {Object} objectA - First object (sphere or box)\n   * @param {Object} objectB - Second object (sphere or box)\n   * @returns {boolean} Whether objects are colliding\n   */\n  checkSphereAABBCollision(objectA, objectB) {\n    const sphere = objectA.collisionType === 'sphere' ? objectA : objectB\n    const box = objectA.collisionType === 'box' ? objectA : objectB\n\n    const boxMin = box.position\n      .clone()\n      .sub(box.size.clone().multiplyScalar(0.5))\n    const boxMax = box.position\n      .clone()\n      .add(box.size.clone().multiplyScalar(0.5))\n\n    // Find closest point on box to sphere center\n    const closestPoint = new THREE.Vector3(\n      Math.max(boxMin.x, Math.min(sphere.position.x, boxMax.x)),\n      Math.max(boxMin.y, Math.min(sphere.position.y, boxMax.y)),\n      Math.max(boxMin.z, Math.min(sphere.position.z, boxMax.z))\n    )\n\n    const distance = sphere.position.distanceTo(closestPoint)\n    return distance <= sphere.radius\n  }\n\n  /**\n   * Check all collisions for a given object\n   * @param {Object} object - Object to check collisions for\n   * @returns {Array} Array of colliding objects\n   */\n  checkCollisions(object) {\n    const collisions = []\n\n    // Check against dynamic colliders\n    for (const collider of this.colliders) {\n      if (collider !== object && this.checkCollision(object, collider)) {\n        collisions.push(collider)\n      }\n    }\n\n    // Check against static colliders\n    for (const collider of this.staticColliders) {\n      if (this.checkCollision(object, collider)) {\n        collisions.push(collider)\n      }\n    }\n\n    return collisions\n  }\n}\n\n/**\n * Underwater physics simulation\n */\nexport class UnderwaterPhysics {\n  constructor() {\n    this.buoyancyForce = 2.0 // Further reduced buoyancy force (was 4.0)\n    this.dragCoefficient = 0.95 // Water resistance (0-1, lower = more drag)\n    this.currentDirection = new THREE.Vector3(0.1, 0, 0.05) // Gentle underwater current\n    this.currentStrength = 0.02\n  }\n\n  /**\n   * Apply buoyancy force to an object\n   * @param {Object} body - Physics body with velocity and position\n   * @param {number} deltaTime - Time since last frame\n   */\n  applyBuoyancy(body, deltaTime) {\n    const buoyancy = new THREE.Vector3(0, this.buoyancyForce * deltaTime, 0)\n    body.velocity.add(buoyancy)\n  }\n\n  /**\n   * Apply drag force to an object\n   * @param {Object} body - Physics body with velocity\n   */\n  applyDrag(body) {\n    body.velocity.multiplyScalar(this.dragCoefficient)\n  }\n\n  /**\n   * Apply underwater current to an object\n   * @param {Object} body - Physics body with velocity\n   * @param {number} currentStrength - Strength multiplier for current effect\n   * @param {number} deltaTime - Time since last frame\n   */\n  applyCurrent(body, currentStrength = 1.0, deltaTime) {\n    const currentForce = this.currentDirection\n      .clone()\n      .multiplyScalar(this.currentStrength * currentStrength * deltaTime)\n    body.velocity.add(currentForce)\n  }\n\n  /**\n   * Apply all underwater physics effects\n   * @param {Object} body - Physics body\n   * @param {number} deltaTime - Time since last frame\n   */\n  applyUnderwaterEffects(body, deltaTime) {\n    this.applyBuoyancy(body, deltaTime)\n    this.applyDrag(body)\n    this.applyCurrent(body, 1.0, deltaTime)\n  }\n}\n\n/**\n * Main Physics Engine\n */\nexport class PhysicsEngine {\n  constructor() {\n    this.gravity = new THREE.Vector3(0, -9.8, 0)\n    this.waterDensity = 1000 // kg/m¬≥\n    this.collisionSystem = new CollisionSystem()\n    this.underwaterPhysics = new UnderwaterPhysics()\n    this.rigidBodies = []\n    this.isUnderwater = true // For now, everything is underwater\n  }\n\n  /**\n   * Add a rigid body to the physics simulation\n   * @param {Object} body - Physics body to add\n   */\n  addRigidBody(body) {\n    this.rigidBodies.push(body)\n\n    // Add to collision system if it has collision properties\n    if (body.collisionType) {\n      this.collisionSystem.addCollider(body, body.isStatic)\n    }\n  }\n\n  /**\n   * Remove a rigid body from the physics simulation\n   * @param {Object} body - Physics body to remove\n   */\n  removeRigidBody(body) {\n    const index = this.rigidBodies.indexOf(body)\n    if (index !== -1) {\n      this.rigidBodies.splice(index, 1)\n      this.collisionSystem.removeCollider(body)\n    }\n  }\n\n  /**\n   * Update all physics bodies\n   * @param {number} deltaTime - Time since last frame\n   */\n  update(deltaTime) {\n    for (const body of this.rigidBodies) {\n      this.updateBody(body, deltaTime)\n    }\n  }\n\n  /**\n   * Update a single physics body\n   * @param {Object} body - Physics body to update\n   * @param {number} deltaTime - Time since last frame\n   */\n  updateBody(body, deltaTime) {\n    if (body.isStatic) {\n      return\n    }\n\n    // Initialize velocity if not present\n    if (!body.velocity) {\n      body.velocity = new THREE.Vector3()\n    }\n\n    // Store previous position for collision resolution\n    const previousPosition = body.position.clone()\n\n    // Apply forces based on environment\n    if (this.isUnderwater) {\n      this.underwaterPhysics.applyUnderwaterEffects(body, deltaTime)\n    } else {\n      // Apply gravity in air\n      const gravityForce = this.gravity.clone().multiplyScalar(deltaTime)\n      body.velocity.add(gravityForce)\n    }\n\n    // Apply velocity to position\n    const velocityDelta = body.velocity.clone().multiplyScalar(deltaTime)\n    body.position.add(velocityDelta)\n\n    // Check collisions and resolve\n    const collisions = this.collisionSystem.checkCollisions(body)\n    if (collisions.length > 0) {\n      this.resolveCollisions(body, collisions, previousPosition)\n    }\n  }\n\n  /**\n   * Resolve collisions for a body\n   * @param {Object} body - Physics body that collided\n   * @param {Array} collisions - Array of colliding objects\n   * @param {THREE.Vector3} previousPosition - Position before collision\n   */\n  resolveCollisions(body, collisions, previousPosition) {\n    // Simple collision resolution: revert to previous position and stop movement\n    body.position.copy(previousPosition)\n\n    // Reduce velocity on collision (bounce/friction)\n    body.velocity.multiplyScalar(0.3)\n\n    // Notify collision callbacks if present\n    if (body.onCollision) {\n      body.onCollision(collisions)\n    }\n  }\n\n  /**\n   * Check collisions for all bodies\n   * @returns {Array} Array of collision pairs\n   */\n  checkCollisions() {\n    const collisionPairs = []\n\n    for (let i = 0; i < this.rigidBodies.length; i++) {\n      const bodyA = this.rigidBodies[i]\n      const collisions = this.collisionSystem.checkCollisions(bodyA)\n\n      for (const bodyB of collisions) {\n        collisionPairs.push([bodyA, bodyB])\n      }\n    }\n\n    return collisionPairs\n  }\n\n  /**\n   * Create a sphere collision body\n   * @param {THREE.Vector3} position - Position of the sphere\n   * @param {number} radius - Radius of the sphere\n   * @param {boolean} isStatic - Whether the body is static\n   * @returns {Object} Collision body\n   */\n  createSphereBody(position, radius, isStatic = false) {\n    return {\n      position: position.clone(),\n      velocity: new THREE.Vector3(),\n      collisionType: 'sphere',\n      radius: radius,\n      isStatic: isStatic,\n    }\n  }\n\n  /**\n   * Create a box collision body\n   * @param {THREE.Vector3} position - Position of the box\n   * @param {THREE.Vector3} size - Size of the box\n   * @param {boolean} isStatic - Whether the body is static\n   * @returns {Object} Collision body\n   */\n  createBoxBody(position, size, isStatic = false) {\n    return {\n      position: position.clone(),\n      velocity: new THREE.Vector3(),\n      collisionType: 'box',\n      size: size.clone(),\n      isStatic: isStatic,\n    }\n  }\n}\n","/**\n * Particle System for Ocean Adventure\n *\n * Creates underwater atmosphere with bubbles, light rays,\n * and collection effects for enhanced immersion.\n */\n\nimport * as THREE from 'three'\n\n/**\n * Individual particle class\n */\nclass Particle {\n  constructor(position, velocity, life, size, color) {\n    this.position = position.clone()\n    this.velocity = velocity.clone()\n    this.life = life\n    this.maxLife = life\n    this.size = size\n    this.color = color.clone()\n    this.alpha = 1.0\n    this.active = true\n  }\n\n  /**\n   * Update particle state\n   * @param {number} deltaTime - Time since last frame\n   */\n  update(deltaTime) {\n    if (!this.active) {\n      return\n    }\n\n    // Update position\n    this.position.add(this.velocity.clone().multiplyScalar(deltaTime))\n\n    // Update life\n    this.life -= deltaTime\n\n    // Update alpha based on life remaining\n    this.alpha = this.life / this.maxLife\n\n    // Deactivate particle if life is over\n    if (this.life <= 0) {\n      this.active = false\n    }\n  }\n\n  /**\n   * Reset particle with new properties\n   * @param {THREE.Vector3} position - New position\n   * @param {THREE.Vector3} velocity - New velocity\n   * @param {number} life - New life span\n   * @param {number} size - New size\n   * @param {THREE.Color} color - New color\n   */\n  reset(position, velocity, life, size, color) {\n    this.position.copy(position)\n    this.velocity.copy(velocity)\n    this.life = life\n    this.maxLife = life\n    this.size = size\n    this.color.copy(color)\n    this.alpha = 1.0\n    this.active = true\n  }\n}\n\n/**\n * Main particle system class\n */\nexport class ParticleSystem {\n  constructor(scene, maxParticles = 1000) {\n    this.scene = scene\n    this.maxParticles = maxParticles\n    this.particles = []\n    this.emitters = []\n\n    // Create particle pool\n    this.initializeParticlePool()\n\n    // Create particle geometry and material\n    this.createParticleRenderSystem()\n\n    // Add default underwater emitters\n    this.createUnderwaterEmitters()\n  }\n\n  /**\n   * Initialize the particle pool for object reuse\n   */\n  initializeParticlePool() {\n    for (let i = 0; i < this.maxParticles; i++) {\n      const particle = new Particle(\n        new THREE.Vector3(),\n        new THREE.Vector3(),\n        1.0,\n        1.0,\n        new THREE.Color(0xffffff)\n      )\n      particle.active = false\n      this.particles.push(particle)\n    }\n  }\n\n  /**\n   * Create the rendering system for particles\n   */\n  createParticleRenderSystem() {\n    // Create geometry for point sprites\n    this.geometry = new THREE.BufferGeometry()\n\n    // Create arrays for particle attributes\n    this.positions = new Float32Array(this.maxParticles * 3)\n    this.colors = new Float32Array(this.maxParticles * 3)\n    this.sizes = new Float32Array(this.maxParticles)\n    this.alphas = new Float32Array(this.maxParticles)\n\n    // Set attributes\n    this.geometry.setAttribute(\n      'position',\n      new THREE.BufferAttribute(this.positions, 3)\n    )\n    this.geometry.setAttribute(\n      'color',\n      new THREE.BufferAttribute(this.colors, 3)\n    )\n    this.geometry.setAttribute('size', new THREE.BufferAttribute(this.sizes, 1))\n    this.geometry.setAttribute(\n      'alpha',\n      new THREE.BufferAttribute(this.alphas, 1)\n    )\n\n    // Create shader material for better underwater effects\n    this.material = new THREE.ShaderMaterial({\n      uniforms: {\n        time: { value: 0.0 },\n        pointTexture: { value: this.createParticleTexture() },\n      },\n      vertexShader: `\n        attribute float size;\n        attribute float alpha;\n        varying float vAlpha;\n        varying vec3 vColor;\n        \n        void main() {\n          vAlpha = alpha;\n          vColor = color;\n          \n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_PointSize = size * (300.0 / -mvPosition.z);\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        uniform sampler2D pointTexture;\n        varying float vAlpha;\n        varying vec3 vColor;\n        \n        void main() {\n          vec4 texColor = texture2D(pointTexture, gl_PointCoord);\n          gl_FragColor = vec4(vColor, vAlpha * texColor.a);\n        }\n      `,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      depthWrite: false,\n    })\n\n    // Create points object\n    this.points = new THREE.Points(this.geometry, this.material)\n    this.scene.add(this.points)\n  }\n\n  /**\n   * Create texture for particles\n   * @returns {THREE.Texture} Particle texture\n   */\n  createParticleTexture() {\n    const canvas = document.createElement('canvas')\n    canvas.width = 64\n    canvas.height = 64\n\n    const context = canvas.getContext('2d')\n    const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32)\n    gradient.addColorStop(0, 'rgba(255,255,255,1)')\n    gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)')\n    gradient.addColorStop(0.4, 'rgba(255,255,255,0.4)')\n    gradient.addColorStop(1, 'rgba(255,255,255,0)')\n\n    context.fillStyle = gradient\n    context.fillRect(0, 0, 64, 64)\n\n    const texture = new THREE.Texture(canvas)\n    texture.needsUpdate = true\n    return texture\n  }\n\n  /**\n   * Create underwater particle emitters\n   */\n  createUnderwaterEmitters() {\n    // Bubble emitter\n    this.addEmitter({\n      type: 'bubbles',\n      position: new THREE.Vector3(0, -10, 0),\n      rate: 5, // particles per second\n      life: 8.0,\n      size: { min: 2, max: 6 },\n      velocity: new THREE.Vector3(0, 2, 0),\n      velocityVariation: new THREE.Vector3(0.5, 0.5, 0.5),\n      color: new THREE.Color(0x87ceeb),\n      colorVariation: 0.1,\n      area: new THREE.Vector3(20, 2, 20), // Emission area\n    })\n\n    // Floating particles (debris/plankton)\n    this.addEmitter({\n      type: 'debris',\n      position: new THREE.Vector3(0, 0, 0),\n      rate: 3,\n      life: 15.0,\n      size: { min: 1, max: 3 },\n      velocity: new THREE.Vector3(0.1, 0.05, 0.1),\n      velocityVariation: new THREE.Vector3(0.3, 0.2, 0.3),\n      color: new THREE.Color(0xffffff),\n      colorVariation: 0.2,\n      area: new THREE.Vector3(40, 20, 40),\n    })\n\n    // Light rays effect (very sparse)\n    this.addEmitter({\n      type: 'lightRays',\n      position: new THREE.Vector3(0, 15, 0),\n      rate: 0.5,\n      life: 20.0,\n      size: { min: 8, max: 15 },\n      velocity: new THREE.Vector3(0, -0.5, 0),\n      velocityVariation: new THREE.Vector3(0.1, 0.2, 0.1),\n      color: new THREE.Color(0xffd700),\n      colorVariation: 0.1,\n      area: new THREE.Vector3(30, 5, 30),\n    })\n  }\n\n  /**\n   * Add a particle emitter\n   * @param {Object} emitterConfig - Configuration for the emitter\n   */\n  addEmitter(emitterConfig) {\n    const emitter = {\n      ...emitterConfig,\n      accumulator: 0.0, // For rate control\n      active: true,\n    }\n    this.emitters.push(emitter)\n  }\n\n  /**\n   * Emit a single particle\n   * @param {Object} emitter - Emitter configuration\n   */\n  emitParticle(emitter) {\n    // Find inactive particle\n    const particle = this.particles.find(p => !p.active)\n    if (!particle) {\n      return\n    } // No available particles\n\n    // Calculate random position within emission area\n    const position = emitter.position\n      .clone()\n      .add(\n        new THREE.Vector3(\n          (Math.random() - 0.5) * emitter.area.x,\n          (Math.random() - 0.5) * emitter.area.y,\n          (Math.random() - 0.5) * emitter.area.z\n        )\n      )\n\n    // Calculate random velocity\n    const velocity = emitter.velocity\n      .clone()\n      .add(\n        new THREE.Vector3(\n          (Math.random() - 0.5) * emitter.velocityVariation.x,\n          (Math.random() - 0.5) * emitter.velocityVariation.y,\n          (Math.random() - 0.5) * emitter.velocityVariation.z\n        )\n      )\n\n    // Calculate random size\n    const size =\n      emitter.size.min + Math.random() * (emitter.size.max - emitter.size.min)\n\n    // Calculate random color\n    const color = emitter.color.clone()\n    if (emitter.colorVariation > 0) {\n      color.offsetHSL(\n        (Math.random() - 0.5) * emitter.colorVariation,\n        0,\n        (Math.random() - 0.5) * emitter.colorVariation * 0.5\n      )\n    }\n\n    // Reset particle with new properties\n    particle.reset(position, velocity, emitter.life, size, color)\n  }\n\n  /**\n   * Create a burst of particles at a specific location\n   * @param {THREE.Vector3} position - Position to emit particles\n   * @param {Object} config - Burst configuration\n   */\n  createBurst(position, config = {}) {\n    const count = config.count || 20\n    const life = config.life || 2.0\n    const velocity = config.velocity || new THREE.Vector3(0, 1, 0)\n    const velocityVariation =\n      config.velocityVariation || new THREE.Vector3(2, 2, 2)\n    const color = config.color || new THREE.Color(0xffd700)\n    const size = config.size || { min: 2, max: 8 }\n\n    for (let i = 0; i < count; i++) {\n      const particle = this.particles.find(p => !p.active)\n      if (!particle) {\n        break\n      }\n\n      const burstVelocity = velocity\n        .clone()\n        .add(\n          new THREE.Vector3(\n            (Math.random() - 0.5) * velocityVariation.x,\n            (Math.random() - 0.5) * velocityVariation.y,\n            (Math.random() - 0.5) * velocityVariation.z\n          )\n        )\n\n      const particleSize = size.min + Math.random() * (size.max - size.min)\n\n      particle.reset(position.clone(), burstVelocity, life, particleSize, color)\n    }\n  }\n\n  /**\n   * Update particle system\n   * @param {number} deltaTime - Time since last frame\n   */\n  update(deltaTime) {\n    // Update emitters\n    for (const emitter of this.emitters) {\n      if (!emitter.active) {\n        continue\n      }\n\n      emitter.accumulator += deltaTime\n      const emissionInterval = 1.0 / emitter.rate\n\n      while (emitter.accumulator >= emissionInterval) {\n        this.emitParticle(emitter)\n        emitter.accumulator -= emissionInterval\n      }\n    }\n\n    // Update particles\n    let activeCount = 0\n    for (let i = 0; i < this.particles.length; i++) {\n      const particle = this.particles[i]\n\n      if (particle.active) {\n        particle.update(deltaTime)\n\n        // Update render attributes\n        const index3 = activeCount * 3\n        this.positions[index3] = particle.position.x\n        this.positions[index3 + 1] = particle.position.y\n        this.positions[index3 + 2] = particle.position.z\n\n        this.colors[index3] = particle.color.r\n        this.colors[index3 + 1] = particle.color.g\n        this.colors[index3 + 2] = particle.color.b\n\n        this.sizes[activeCount] = particle.size\n        this.alphas[activeCount] = particle.alpha\n\n        activeCount++\n      }\n    }\n\n    // Update geometry\n    this.geometry.attributes.position.needsUpdate = true\n    this.geometry.attributes.color.needsUpdate = true\n    this.geometry.attributes.size.needsUpdate = true\n    this.geometry.attributes.alpha.needsUpdate = true\n\n    // Update draw range to only render active particles\n    this.geometry.setDrawRange(0, activeCount)\n\n    // Update shader uniforms\n    this.material.uniforms.time.value += deltaTime\n  }\n\n  /**\n   * Set emitter active state\n   * @param {string} type - Emitter type\n   * @param {boolean} active - Whether emitter should be active\n   */\n  setEmitterActive(type, active) {\n    const emitter = this.emitters.find(e => e.type === type)\n    if (emitter) {\n      emitter.active = active\n    }\n  }\n\n  /**\n   * Remove all particles\n   */\n  clear() {\n    for (const particle of this.particles) {\n      particle.active = false\n    }\n  }\n\n  /**\n   * Dispose of particle system resources\n   */\n  dispose() {\n    this.scene.remove(this.points)\n    this.geometry.dispose()\n    this.material.dispose()\n    if (this.material.uniforms.pointTexture.value) {\n      this.material.uniforms.pointTexture.value.dispose()\n    }\n  }\n}\n","/**\n * Player Component for Ocean Adventure\n *\n * Enhanced player controller with physics integration,\n * underwater movement mechanics, and collision handling.\n */\n\nimport * as THREE from 'three'\n\nexport class Player {\n  constructor(scene, physicsEngine) {\n    this.scene = scene\n    this.physicsEngine = physicsEngine\n\n    // Player properties\n    this.moveSpeed = 8.0\n    this.rotationSpeed = 3.0\n    this.maxVelocity = 5.0\n\n    // Movement state\n    this.movementVector = new THREE.Vector3()\n    this.isMoving = false\n\n    // Create player mesh and physics body\n    this.createPlayerMesh()\n    this.createPhysicsBody()\n\n    // Bind collision handler\n    this.physicsBody.onCollision = collisions =>\n      this.handleCollisions(collisions)\n  }\n\n  /**\n   * Create the visual representation of the player\n   */\n  createPlayerMesh() {\n    // Create player geometry (capsule for better collision detection)\n    const geometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8)\n    const material = new THREE.MeshLambertMaterial({\n      color: 0x00ff88,\n      transparent: true,\n      opacity: 0.9,\n    })\n\n    this.mesh = new THREE.Mesh(geometry, material)\n    this.mesh.castShadow = true\n    this.mesh.receiveShadow = true\n\n    // Set initial position - start underwater with some depth\n    this.mesh.position.set(0, 2, 0) // Start 3 meters below water surface (5 - 2 = 3m depth)\n\n    // Add to scene\n    this.scene.add(this.mesh)\n  }\n\n  /**\n   * Create physics body for collision detection and movement\n   */\n  createPhysicsBody() {\n    this.physicsBody = this.physicsEngine.createSphereBody(\n      this.mesh.position.clone(), // Use the mesh position which is now set to (0, 2, 0)\n      0.7, // Slightly larger radius for collision detection\n      false // Not static - player can move\n    )\n\n    // Add physics body to engine\n    this.physicsEngine.addRigidBody(this.physicsBody)\n  }\n\n  /**\n   * Handle input and update movement vector\n   * @param {Object} inputState - Current input state\n   */\n  handleInput(inputState) {\n    // Reset movement vector\n    this.movementVector.set(0, 0, 0)\n    this.isMoving = false\n\n    // Keyboard input\n    if (inputState.keys) {\n      if (inputState.keys.forward) {\n        this.movementVector.z -= 1\n        this.isMoving = true\n      }\n      if (inputState.keys.backward) {\n        this.movementVector.z += 1\n        this.isMoving = true\n      }\n      if (inputState.keys.left) {\n        this.movementVector.x -= 1\n        this.isMoving = true\n      }\n      if (inputState.keys.right) {\n        this.movementVector.x += 1\n        this.isMoving = true\n      }\n      if (inputState.keys.up) {\n        this.movementVector.y += 1\n        this.isMoving = true\n      }\n      if (inputState.keys.down) {\n        this.movementVector.y -= 1\n        this.isMoving = true\n      }\n    }\n\n    // Touch/mobile input\n    if (inputState.joystick) {\n      this.movementVector.x += inputState.joystick.x\n      this.movementVector.z += inputState.joystick.y\n      if (\n        Math.abs(inputState.joystick.x) > 0.1 ||\n        Math.abs(inputState.joystick.y) > 0.1\n      ) {\n        this.isMoving = true\n      }\n    }\n\n    // Mobile buttons\n    if (inputState.mobileButtons) {\n      if (inputState.mobileButtons.swimUp) {\n        this.movementVector.y += 1\n        this.isMoving = true\n      }\n      if (inputState.mobileButtons.swimDown) {\n        this.movementVector.y -= 1\n        this.isMoving = true\n      }\n    }\n\n    // Normalize movement vector to prevent faster diagonal movement\n    if (this.movementVector.length() > 1) {\n      this.movementVector.normalize()\n    }\n\n    // Apply movement to physics body\n    this.applyMovement()\n  }\n\n  /**\n   * Apply movement forces to the physics body\n   */\n  applyMovement() {\n    if (!this.isMoving) {\n      // Apply stronger drag when not actively moving\n      this.physicsBody.velocity.multiplyScalar(0.9)\n      return\n    }\n\n    // Calculate movement force\n    const force = this.movementVector\n      .clone()\n      .multiplyScalar(this.moveSpeed * 0.016) // Assume ~60fps for consistent feel\n\n    // Add force to velocity\n    this.physicsBody.velocity.add(force)\n\n    // Clamp velocity to max speed\n    if (this.physicsBody.velocity.length() > this.maxVelocity) {\n      this.physicsBody.velocity.normalize().multiplyScalar(this.maxVelocity)\n    }\n\n    // Rotate player to face movement direction (optional visual enhancement)\n    if (this.movementVector.length() > 0.1) {\n      const targetRotation = Math.atan2(\n        this.movementVector.x,\n        this.movementVector.z\n      )\n      this.mesh.rotation.y = THREE.MathUtils.lerp(\n        this.mesh.rotation.y,\n        targetRotation,\n        this.rotationSpeed * 0.016\n      )\n    }\n  }\n\n  /**\n   * Update player state\n   */\n  update() {\n    // Sync mesh position with physics body (don't override physics with floating animation)\n    this.mesh.position.copy(this.physicsBody.position)\n\n    // Add gentle floating animation to visual representation only\n    const time = Date.now() * 0.001\n    const floatingOffset = Math.sin(time * 2) * 0.02\n    this.mesh.position.y += floatingOffset\n\n    // Don't update physics body position from mesh - let physics handle position\n    // The physics body position should be authoritative\n  }\n\n  /**\n   * Handle collisions with other objects\n   * @param {Array} collisions - Array of objects the player collided with\n   */\n  handleCollisions(collisions) {\n    for (const collision of collisions) {\n      // Handle different types of collisions\n      if (collision.type === 'collectible') {\n        this.handleCollectibleCollision(collision)\n      } else if (collision.type === 'obstacle') {\n        this.handleObstacleCollision(collision)\n      } else if (collision.type === 'environment') {\n        this.handleEnvironmentCollision(collision)\n      }\n    }\n  }\n\n  /**\n   * Handle collision with collectible items\n   * @param {Object} collectible - Collectible object\n   */\n  handleCollectibleCollision(collectible) {\n    // Collectibles will be handled by the game manager\n    // This is just for reference and future expansion\n    console.log('Player collected item:', collectible)\n  }\n\n  /**\n   * Handle collision with obstacles\n   * @param {Object} obstacle - Obstacle object\n   */\n  handleObstacleCollision(obstacle) {\n    // Bounce back slightly from obstacles\n    const direction = this.physicsBody.position\n      .clone()\n      .sub(obstacle.position)\n      .normalize()\n\n    this.physicsBody.velocity.add(direction.multiplyScalar(2))\n  }\n\n  /**\n   * Handle collision with environment objects\n   * @param {Object} _envObject - Environment object (unused for now)\n   */\n  handleEnvironmentCollision() {\n    // Environment collisions are handled by physics engine\n    // This can be used for special effects or sounds\n  }\n\n  /**\n   * Get current player position\n   * @returns {THREE.Vector3} Current position\n   */\n  getPosition() {\n    return this.mesh.position.clone()\n  }\n\n  /**\n   * Set player position\n   * @param {THREE.Vector3} position - New position\n   */\n  setPosition(position) {\n    this.mesh.position.copy(position)\n    this.physicsBody.position.copy(position)\n  }\n\n  /**\n   * Get current velocity\n   * @returns {THREE.Vector3} Current velocity\n   */\n  getVelocity() {\n    return this.physicsBody.velocity.clone()\n  }\n\n  /**\n   * Check if player is moving\n   * @returns {boolean} Whether player is currently moving\n   */\n  getIsMoving() {\n    return this.isMoving || this.physicsBody.velocity.length() > 0.1\n  }\n\n  /**\n   * Dispose of player resources\n   */\n  dispose() {\n    // Remove from physics engine\n    this.physicsEngine.removeRigidBody(this.physicsBody)\n\n    // Remove mesh from scene\n    this.scene.remove(this.mesh)\n\n    // Dispose geometry and material\n    this.mesh.geometry.dispose()\n    this.mesh.material.dispose()\n  }\n}\n","/**\n * Ocean Adventure - Main Game Entry Point\n *\n * This is a placeholder implementation showing the basic structure\n * for the 3D underwater platform game. The actual game engine\n * implementation will be developed following the Copilot plan.\n */\n\nimport * as THREE from 'three'\nimport { PhysicsEngine } from './core/Physics.js'\nimport { ParticleSystem } from './core/ParticleSystem.js'\nimport { Player } from './components/Player.js'\n\n// Game configuration\nconst CONFIG = {\n  targetFPS: 60,\n  mobileFPS: 30,\n  canvasId: 'gameCanvas',\n  loadingId: 'loading',\n  uiId: 'ui',\n}\n\nclass OceanAdventure {\n  constructor() {\n    this.scene = null\n    this.camera = null\n    this.renderer = null\n    this.canvas = null\n    this.isLoaded = false\n    this.isMobile = this.detectMobile()\n\n    // Core systems\n    this.physicsEngine = null\n    this.particleSystem = null\n    this.player = null\n    this.environmentObjects = []\n\n    // Game state\n    this.starCount = 0\n    this.levelNumber = 1\n\n    // Input state\n    this.inputState = {\n      keys: {\n        forward: false,\n        backward: false,\n        left: false,\n        right: false,\n        up: false,\n        down: false,\n      },\n      joystick: { x: 0, y: 0 },\n      mobileButtons: { swimUp: false, swimDown: false },\n    }\n\n    // Timing\n    this.lastTime = 0\n\n    console.log('üåä Ocean Adventure - Initializing...')\n  }\n\n  async initialize() {\n    try {\n      this.setupCanvas()\n      this.setupRenderer()\n      this.setupScene()\n      this.setupCamera()\n      this.setupLights()\n\n      // Initialize core systems\n      this.initializePhysics()\n      this.initializeParticleSystem()\n\n      // Create game objects\n      this.createUnderwaterEnvironment()\n      this.createPlayer()\n      this.createSampleStars()\n\n      this.setupEventListeners()\n\n      // Hide loading screen and show UI\n      this.hideLoading()\n      this.showUI()\n\n      // Start game loop\n      this.startGameLoop()\n\n      this.isLoaded = true\n      console.log('üéÆ Ocean Adventure - Ready to play!')\n    } catch (error) {\n      console.error('‚ùå Failed to initialize game:', error)\n    }\n  }\n\n  setupCanvas() {\n    this.canvas = document.getElementById(CONFIG.canvasId)\n    if (!this.canvas) {\n      throw new Error('Game canvas not found')\n    }\n  }\n\n  setupRenderer() {\n    try {\n      this.renderer = new THREE.WebGLRenderer({\n        canvas: this.canvas,\n        antialias: !this.isMobile, // Disable antialiasing on mobile for performance\n        alpha: false,\n        powerPreference: this.isMobile ? 'low-power' : 'high-performance',\n        failIfMajorPerformanceCaveat: false, // Allow fallback rendering\n        preserveDrawingBuffer: false, // Better performance\n        premultipliedAlpha: false,\n        stencil: false, // Reduce memory usage\n      })\n\n      this.renderer.setSize(window.innerWidth, window.innerHeight)\n      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n      this.renderer.setClearColor(0x001122, 1) // Deep ocean blue\n\n      // Enable shadows for better visual quality (but not on mobile)\n      if (!this.isMobile) {\n        this.renderer.shadowMap.enabled = true\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap\n      }\n\n      // Validate WebGL context\n      const gl = this.renderer.getContext()\n      if (!gl) {\n        throw new Error('Failed to get WebGL context')\n      }\n\n      // Add error handling for WebGL\n      gl.getExtension('WEBGL_lose_context')\n\n      console.log('‚úÖ WebGL Renderer initialized successfully')\n    } catch (error) {\n      console.error('‚ùå Failed to setup renderer:', error)\n      throw error\n    }\n  }\n\n  setupScene() {\n    this.scene = new THREE.Scene()\n  }\n\n  /**\n   * Initialize physics engine\n   */\n  initializePhysics() {\n    this.physicsEngine = new PhysicsEngine()\n    console.log('‚ö° Physics engine initialized')\n  }\n\n  /**\n   * Initialize particle system\n   */\n  initializeParticleSystem() {\n    this.particleSystem = new ParticleSystem(this.scene, 500) // Reduced for mobile performance\n    console.log('‚ú® Particle system initialized')\n  }\n\n  setupCamera() {\n    this.camera = new THREE.PerspectiveCamera(\n      75, // Field of view\n      window.innerWidth / window.innerHeight, // Aspect ratio\n      0.1, // Near clipping plane\n      1000 // Far clipping plane\n    )\n\n    // Position camera behind and above the player\n    this.camera.position.set(0, 5, 10)\n    this.camera.lookAt(0, 0, 0)\n  }\n\n  setupLights() {\n    // Ambient light for underwater ambience\n    const ambientLight = new THREE.AmbientLight(0x404080, 0.4)\n    this.scene.add(ambientLight)\n\n    // Directional light simulating filtered sunlight\n    const directionalLight = new THREE.DirectionalLight(0x87ceeb, 0.8)\n    directionalLight.position.set(0, 50, 0)\n\n    // Only enable shadows on desktop for better compatibility\n    if (!this.isMobile && this.renderer.shadowMap.enabled) {\n      directionalLight.castShadow = true\n      directionalLight.shadow.mapSize.width = 1024 // Reduced for better compatibility\n      directionalLight.shadow.mapSize.height = 1024\n      directionalLight.shadow.camera.near = 0.5\n      directionalLight.shadow.camera.far = 500\n      directionalLight.shadow.camera.left = -50\n      directionalLight.shadow.camera.right = 50\n      directionalLight.shadow.camera.top = 50\n      directionalLight.shadow.camera.bottom = -50\n    }\n\n    this.scene.add(directionalLight)\n  }\n\n  createUnderwaterEnvironment() {\n    // Create ocean floor\n    const floorGeometry = new THREE.PlaneGeometry(100, 100)\n    const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 })\n    const floor = new THREE.Mesh(floorGeometry, floorMaterial)\n    floor.rotation.x = -Math.PI / 2\n    floor.position.y = -5\n    floor.receiveShadow = true\n    this.scene.add(floor)\n\n    // Create physics body for floor\n    const floorPhysicsBody = this.physicsEngine.createBoxBody(\n      new THREE.Vector3(0, -5, 0),\n      new THREE.Vector3(100, 0.1, 100),\n      true // Static\n    )\n    floorPhysicsBody.type = 'environment'\n    this.physicsEngine.addRigidBody(floorPhysicsBody)\n\n    // Add coral/rocks with collision detection\n    for (let i = 0; i < 10; i++) {\n      const radius = 0.5 + Math.random() * 1.5\n      const geometry = new THREE.SphereGeometry(radius)\n      const material = new THREE.MeshLambertMaterial({\n        color: new THREE.Color().setHSL(Math.random() * 0.3, 0.7, 0.5),\n      })\n      const coral = new THREE.Mesh(geometry, material)\n\n      const position = new THREE.Vector3(\n        (Math.random() - 0.5) * 80,\n        -4 + Math.random() * 2,\n        (Math.random() - 0.5) * 80\n      )\n      coral.position.copy(position)\n      coral.castShadow = true\n      this.scene.add(coral)\n\n      // Add physics body for collision\n      const coralPhysicsBody = this.physicsEngine.createSphereBody(\n        position,\n        radius * 1.2, // Slightly larger for collision detection\n        true // Static\n      )\n      coralPhysicsBody.type = 'environment'\n      coralPhysicsBody.mesh = coral // Reference to visual representation\n      this.physicsEngine.addRigidBody(coralPhysicsBody)\n      this.environmentObjects.push({\n        mesh: coral,\n        physicsBody: coralPhysicsBody,\n      })\n    }\n  }\n\n  createPlayer() {\n    // Create enhanced player with physics\n    this.player = new Player(this.scene, this.physicsEngine)\n    console.log('üèä Player created with physics')\n  }\n\n  createSampleStars() {\n    this.stars = []\n\n    // Create glowing star collectibles with physics\n    for (let i = 0; i < 5; i++) {\n      const starGeometry = new THREE.SphereGeometry(0.3)\n      const starMaterial = new THREE.MeshLambertMaterial({\n        color: 0xffd700,\n        emissive: 0xffd700,\n        emissiveIntensity: 0.3,\n      })\n\n      const star = new THREE.Mesh(starGeometry, starMaterial)\n      const position = new THREE.Vector3(\n        (Math.random() - 0.5) * 20,\n        Math.random() * 8 - 2,\n        (Math.random() - 0.5) * 20\n      )\n      star.position.copy(position)\n\n      // Add physics body for collision detection\n      const starPhysicsBody = this.physicsEngine.createSphereBody(\n        position,\n        0.5, // Slightly larger for easier collection\n        true // Static - stars don't move\n      )\n      starPhysicsBody.type = 'collectible'\n      starPhysicsBody.mesh = star\n      starPhysicsBody.collected = false\n      this.physicsEngine.addRigidBody(starPhysicsBody)\n\n      // Add simple rotation animation\n      star.userData = {\n        rotationSpeed: 0.02 + Math.random() * 0.02,\n        physicsBody: starPhysicsBody,\n      }\n\n      this.stars.push({ mesh: star, physicsBody: starPhysicsBody })\n      this.scene.add(star)\n    }\n  }\n\n  setupEventListeners() {\n    // Handle window resize\n    window.addEventListener('resize', () => this.onWindowResize())\n\n    // Enhanced input handling\n    window.addEventListener('keydown', event => this.onKeyDown(event))\n    window.addEventListener('keyup', event => this.onKeyUp(event))\n\n    // Touch controls for mobile\n    if (this.isMobile) {\n      this.setupTouchControls()\n    }\n\n    // Settings modal functionality\n    this.setupSettingsModal()\n  }\n\n  onKeyDown(event) {\n    switch (event.code) {\n      case 'ArrowUp':\n      case 'KeyW':\n        this.inputState.keys.forward = true\n        break\n      case 'ArrowDown':\n      case 'KeyS':\n        this.inputState.keys.backward = true\n        break\n      case 'ArrowLeft':\n      case 'KeyA':\n        this.inputState.keys.left = true\n        break\n      case 'ArrowRight':\n      case 'KeyD':\n        this.inputState.keys.right = true\n        break\n      case 'Space':\n        this.inputState.keys.up = true\n        event.preventDefault()\n        break\n      case 'ShiftLeft':\n        this.inputState.keys.down = true\n        break\n    }\n  }\n\n  onKeyUp(event) {\n    switch (event.code) {\n      case 'ArrowUp':\n      case 'KeyW':\n        this.inputState.keys.forward = false\n        break\n      case 'ArrowDown':\n      case 'KeyS':\n        this.inputState.keys.backward = false\n        break\n      case 'ArrowLeft':\n      case 'KeyA':\n        this.inputState.keys.left = false\n        break\n      case 'ArrowRight':\n      case 'KeyD':\n        this.inputState.keys.right = false\n        break\n      case 'Space':\n        this.inputState.keys.up = false\n        break\n      case 'ShiftLeft':\n        this.inputState.keys.down = false\n        break\n    }\n  }\n\n  setupTouchControls() {\n    // Setup virtual joystick\n    this.setupVirtualJoystick()\n\n    // Setup mobile action buttons\n    this.setupMobileButtons()\n\n    // Touch control state for general canvas interactions\n    this.touchState = {\n      startX: 0,\n      startY: 0,\n      currentX: 0,\n      currentY: 0,\n      isActive: false,\n    }\n\n    // General canvas touch events (for swipe gestures)\n    this.canvas.addEventListener('touchstart', event => {\n      event.preventDefault()\n      if (event.touches.length > 0) {\n        const touch = event.touches[0]\n        this.touchState.startX = touch.clientX\n        this.touchState.startY = touch.clientY\n        this.touchState.currentX = touch.clientX\n        this.touchState.currentY = touch.clientY\n        this.touchState.isActive = true\n      }\n    })\n\n    this.canvas.addEventListener('touchmove', event => {\n      event.preventDefault()\n      if (event.touches.length > 0 && this.touchState.isActive) {\n        const touch = event.touches[0]\n        this.touchState.currentX = touch.clientX\n        this.touchState.currentY = touch.clientY\n\n        // Calculate movement delta for swipe gestures\n        const deltaX = this.touchState.currentX - this.touchState.startX\n        const deltaY = this.touchState.currentY - this.touchState.startY\n\n        // Apply gentle swipe-based movement (subtle effect)\n        const moveSpeed = 0.05\n        const sensitivity = 3\n\n        if (Math.abs(deltaX) > 20) {\n          this.player.position.x += (deltaX / sensitivity) * moveSpeed * 0.01\n        }\n\n        if (Math.abs(deltaY) > 20) {\n          this.player.position.z += (deltaY / sensitivity) * moveSpeed * 0.01\n        }\n\n        this.updateCamera()\n      }\n    })\n\n    this.canvas.addEventListener('touchend', event => {\n      event.preventDefault()\n      this.touchState.isActive = false\n    })\n\n    this.canvas.addEventListener('touchcancel', event => {\n      event.preventDefault()\n      this.touchState.isActive = false\n    })\n  }\n\n  setupVirtualJoystick() {\n    const joystick = document.getElementById('virtualJoystick')\n    const knob = document.getElementById('joystickKnob')\n\n    if (!joystick || !knob) {\n      return\n    }\n\n    const joystickState = {\n      isActive: false,\n      centerX: 0,\n      centerY: 0,\n      currentX: 0,\n      currentY: 0,\n    }\n\n    joystick.addEventListener('touchstart', event => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      if (event.touches.length > 0) {\n        const touch = event.touches[0]\n        const rect = joystick.getBoundingClientRect()\n\n        joystickState.isActive = true\n        joystickState.centerX = rect.left + rect.width / 2\n        joystickState.centerY = rect.top + rect.height / 2\n        joystickState.currentX = touch.clientX\n        joystickState.currentY = touch.clientY\n\n        // Visual feedback - highlight joystick when active\n        joystick.style.borderColor = 'rgba(255, 255, 255, 0.6)'\n        joystick.style.background = 'rgba(0, 17, 34, 0.7)'\n\n        this.updateJoystickKnob(knob, joystickState, rect)\n      }\n    })\n\n    joystick.addEventListener('touchmove', event => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      if (event.touches.length > 0 && joystickState.isActive) {\n        const touch = event.touches[0]\n        const rect = joystick.getBoundingClientRect()\n\n        joystickState.currentX = touch.clientX\n        joystickState.currentY = touch.clientY\n\n        // Calculate movement vector\n        const deltaX = joystickState.currentX - joystickState.centerX\n        const deltaY = joystickState.currentY - joystickState.centerY\n        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n        const maxDistance = rect.width / 2 - 20\n\n        // Normalize and apply movement\n        if (distance > 5) {\n          const normalizedX = deltaX / maxDistance\n          const normalizedY = deltaY / maxDistance\n\n          // Update input state with improved sensitivity for mobile\n          this.inputState.joystick.x = Math.max(\n            -1,\n            Math.min(1, normalizedX * 1.2)\n          )\n          this.inputState.joystick.y = Math.max(\n            -1,\n            Math.min(1, normalizedY * 1.2)\n          )\n        } else {\n          this.inputState.joystick.x = 0\n          this.inputState.joystick.y = 0\n        }\n\n        this.updateJoystickKnob(knob, joystickState, rect)\n      }\n    })\n\n    joystick.addEventListener('touchend', event => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      joystickState.isActive = false\n      this.inputState.joystick.x = 0\n      this.inputState.joystick.y = 0\n\n      // Reset visual feedback\n      joystick.style.borderColor = 'rgba(255, 255, 255, 0.3)'\n      joystick.style.background = 'rgba(0, 17, 34, 0.5)'\n      knob.style.transform = 'translate(-50%, -50%)'\n    })\n\n    joystick.addEventListener('touchcancel', event => {\n      event.preventDefault()\n      event.stopPropagation()\n\n      joystickState.isActive = false\n      this.inputState.joystick.x = 0\n      this.inputState.joystick.y = 0\n\n      // Reset visual feedback\n      joystick.style.borderColor = 'rgba(255, 255, 255, 0.3)'\n      joystick.style.background = 'rgba(0, 17, 34, 0.5)'\n      knob.style.transform = 'translate(-50%, -50%)'\n    })\n  }\n\n  updateJoystickKnob(knob, joystickState, rect) {\n    const deltaX = joystickState.currentX - joystickState.centerX\n    const deltaY = joystickState.currentY - joystickState.centerY\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY)\n    const maxDistance = rect.width / 2 - 20\n\n    if (distance <= maxDistance) {\n      knob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`\n    } else {\n      const angle = Math.atan2(deltaY, deltaX)\n      const x = Math.cos(angle) * maxDistance\n      const y = Math.sin(angle) * maxDistance\n      knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`\n    }\n  }\n\n  setupMobileButtons() {\n    const swimUpBtn = document.getElementById('swimUpBtn')\n    const swimDownBtn = document.getElementById('swimDownBtn')\n\n    if (swimUpBtn) {\n      // Add more responsive event handling\n      swimUpBtn.addEventListener('touchstart', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimUp = true\n        swimUpBtn.style.background = 'rgba(255, 255, 255, 0.4)'\n      })\n\n      swimUpBtn.addEventListener('touchend', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimUp = false\n        swimUpBtn.style.background = 'rgba(0, 17, 34, 0.6)'\n      })\n\n      swimUpBtn.addEventListener('touchcancel', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimUp = false\n        swimUpBtn.style.background = 'rgba(0, 17, 34, 0.6)'\n      })\n    }\n\n    if (swimDownBtn) {\n      // Add more responsive event handling\n      swimDownBtn.addEventListener('touchstart', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimDown = true\n        swimDownBtn.style.background = 'rgba(255, 255, 255, 0.4)'\n      })\n\n      swimDownBtn.addEventListener('touchend', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimDown = false\n        swimDownBtn.style.background = 'rgba(0, 17, 34, 0.6)'\n      })\n\n      swimDownBtn.addEventListener('touchcancel', event => {\n        event.preventDefault()\n        event.stopPropagation()\n        this.inputState.mobileButtons.swimDown = false\n        swimDownBtn.style.background = 'rgba(0, 17, 34, 0.6)'\n      })\n    }\n  }\n\n  setupSettingsModal() {\n    const settingsButton = document.getElementById('settingsButton')\n    const settingsModal = document.getElementById('settingsModal')\n    const closeSettings = document.getElementById('closeSettings')\n\n    if (settingsButton && settingsModal && closeSettings) {\n      // Open settings\n      const openSettings = event => {\n        if (event) {\n          event.preventDefault()\n          event.stopPropagation()\n        }\n        settingsModal.classList.remove('hidden')\n        // Prevent body scrolling when modal is open\n        document.body.style.overflow = 'hidden'\n      }\n\n      // Close settings\n      const closeModal = event => {\n        if (event) {\n          event.preventDefault()\n          event.stopPropagation()\n        }\n        settingsModal.classList.add('hidden')\n        // Restore body scrolling\n        document.body.style.overflow = ''\n      }\n\n      // Simple event handling - click events work on both desktop and mobile\n      settingsButton.addEventListener('click', openSettings)\n      closeSettings.addEventListener('click', closeModal)\n\n      // Close on background click - works on both desktop and mobile\n      settingsModal.addEventListener('click', event => {\n        if (event.target === settingsModal) {\n          closeModal(event)\n        }\n      })\n\n      // Close on escape key\n      document.addEventListener('keydown', event => {\n        if (\n          event.key === 'Escape' &&\n          !settingsModal.classList.contains('hidden')\n        ) {\n          closeModal()\n        }\n      })\n    }\n  }\n\n  onWindowResize() {\n    this.camera.aspect = window.innerWidth / window.innerHeight\n    this.camera.updateProjectionMatrix()\n    this.renderer.setSize(window.innerWidth, window.innerHeight)\n  }\n\n  updateCamera() {\n    // Enhanced camera follow logic\n    const playerPosition = this.player.getPosition()\n    const offset = new THREE.Vector3(0, 5, 10)\n    const targetPosition = playerPosition.clone().add(offset)\n\n    this.camera.position.lerp(targetPosition, 0.1)\n    this.camera.lookAt(playerPosition)\n  }\n\n  startGameLoop() {\n    const animate = currentTime => {\n      requestAnimationFrame(animate)\n\n      // Calculate delta time\n      const deltaTime =\n        this.lastTime > 0 ? (currentTime - this.lastTime) / 1000 : 0.016\n      this.lastTime = currentTime\n\n      this.update(deltaTime)\n      this.render()\n    }\n    animate(0)\n  }\n\n  update(deltaTime) {\n    if (!this.isLoaded) {\n      return\n    }\n\n    // Clamp delta time to prevent large jumps\n    deltaTime = Math.min(deltaTime, 0.033) // Max 30fps equivalent\n\n    // Update physics engine\n    this.physicsEngine.update(deltaTime)\n\n    // Update player with input\n    this.player.handleInput(this.inputState)\n    this.player.update()\n\n    // Update particle system\n    this.particleSystem.update(deltaTime)\n\n    // Update camera\n    this.updateCamera()\n\n    // Update UI (including depth meter)\n    this.updateUI()\n\n    // Animate stars\n    this.stars.forEach(starData => {\n      const star = starData.mesh\n      star.rotation.y += star.userData.rotationSpeed\n      star.rotation.x += star.userData.rotationSpeed * 0.5\n    })\n\n    // Check star collection using collision detection\n    this.checkStarCollection()\n  }\n\n  checkStarCollection() {\n    // Get player collisions from physics engine\n    const playerCollisions = this.physicsEngine.collisionSystem.checkCollisions(\n      this.player.physicsBody\n    )\n\n    for (const collision of playerCollisions) {\n      if (collision.type === 'collectible' && !collision.collected) {\n        // Collect star\n        collision.collected = true\n\n        // Find and remove the star from scene and physics\n        const starData = this.stars.find(s => s.physicsBody === collision)\n        if (starData) {\n          // Remove from scene\n          this.scene.remove(starData.mesh)\n\n          // Remove from physics\n          this.physicsEngine.removeRigidBody(starData.physicsBody)\n\n          // Remove from stars array\n          const index = this.stars.indexOf(starData)\n          if (index !== -1) {\n            this.stars.splice(index, 1)\n          }\n\n          // Update game state\n          this.starCount++\n          this.updateUI()\n\n          // Create collection effect\n          this.particleSystem.createBurst(starData.mesh.position, {\n            count: 15,\n            life: 1.5,\n            velocity: new THREE.Vector3(0, 2, 0),\n            velocityVariation: new THREE.Vector3(3, 3, 3),\n            color: new THREE.Color(0xffd700),\n            size: { min: 3, max: 8 },\n          })\n\n          console.log(`‚≠ê Star collected! Total: ${this.starCount}`)\n\n          // Check if level is complete\n          if (this.stars.length === 0) {\n            this.levelComplete()\n          }\n        }\n      }\n    }\n  }\n\n  levelComplete() {\n    console.log('üéâ Level Complete!')\n    this.levelNumber++\n    // Reset level with new stars\n    this.createSampleStars()\n    this.updateUI()\n  }\n\n  updateUI() {\n    document.getElementById('starCount').textContent = this.starCount\n    document.getElementById('levelNumber').textContent = this.levelNumber\n\n    // Update depth meter based on player Y position\n    if (this.player) {\n      const playerPosition = this.player.getPosition()\n      // Water surface is at Y=5, so depth = surface level - current Y position\n      const waterSurface = 5.0\n      const depth = Math.max(0, waterSurface - playerPosition.y)\n      document.getElementById('depthMeter').textContent = depth.toFixed(1)\n    }\n  }\n\n  render() {\n    try {\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera)\n      }\n    } catch (error) {\n      // Silently handle WebGL render errors to prevent spam\n      if (this.webglErrorCount < 5) {\n        console.warn('WebGL render error:', error)\n        this.webglErrorCount = (this.webglErrorCount || 0) + 1\n      }\n    }\n  }\n\n  hideLoading() {\n    const loadingElement = document.getElementById(CONFIG.loadingId)\n    if (loadingElement) {\n      loadingElement.classList.add('hidden')\n    }\n  }\n\n  showUI() {\n    const uiElement = document.getElementById(CONFIG.uiId)\n    if (uiElement) {\n      uiElement.classList.remove('hidden')\n    }\n    this.updateUI()\n  }\n\n  detectMobile() {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    )\n  }\n}\n\n// Initialize the game when the page loads\nwindow.addEventListener('DOMContentLoaded', async () => {\n  const game = new OceanAdventure()\n  await game.initialize()\n})\n\n// Handle WebGL context loss\nwindow.addEventListener('webglcontextlost', event => {\n  event.preventDefault()\n  console.warn('WebGL context lost')\n})\n\nwindow.addEventListener('webglcontextrestored', () => {\n  console.log('WebGL context restored')\n  // Reinitialize game here if needed\n})\n"],"names":["CollisionSystem","constructor","this","colliders","staticColliders","addCollider","collider","isStatic","push","removeCollider","index","indexOf","splice","checkCollision","objectA","objectB","collisionType","checkSphereCollision","checkAABBCollision","checkSphereAABBCollision","sphereA","sphereB","position","distanceTo","radius","boxA","boxB","minA","clone","sub","size","multiplyScalar","maxA","add","minB","maxB","x","y","z","sphere","box","boxMin","boxMax","closestPoint","THREE.Vector3","Math","max","min","checkCollisions","object","collisions","UnderwaterPhysics","buoyancyForce","dragCoefficient","currentDirection","currentStrength","applyBuoyancy","body","deltaTime","buoyancy","velocity","applyDrag","applyCurrent","currentForce","applyUnderwaterEffects","PhysicsEngine","gravity","waterDensity","collisionSystem","underwaterPhysics","rigidBodies","isUnderwater","addRigidBody","removeRigidBody","update","updateBody","previousPosition","gravityForce","velocityDelta","length","resolveCollisions","copy","onCollision","collisionPairs","i","bodyA","bodyB","createSphereBody","createBoxBody","Particle","life","color","maxLife","alpha","active","reset","ParticleSystem","scene","maxParticles","particles","emitters","initializeParticlePool","createParticleRenderSystem","createUnderwaterEmitters","particle","THREE.Color","geometry","THREE.BufferGeometry","positions","Float32Array","colors","sizes","alphas","setAttribute","THREE.BufferAttribute","material","THREE.ShaderMaterial","uniforms","time","value","pointTexture","createParticleTexture","vertexShader","fragmentShader","transparent","blending","THREE.AdditiveBlending","depthWrite","points","THREE.Points","canvas","document","createElement","width","height","context","getContext","gradient","createRadialGradient","addColorStop","fillStyle","fillRect","texture","THREE.Texture","needsUpdate","addEmitter","type","rate","velocityVariation","colorVariation","area","emitterConfig","emitter","accumulator","emitParticle","find","p","random","offsetHSL","createBurst","config","count","burstVelocity","particleSize","emissionInterval","activeCount","index3","r","g","b","attributes","setDrawRange","setEmitterActive","e","clear","dispose","remove","Player","physicsEngine","moveSpeed","rotationSpeed","maxVelocity","movementVector","isMoving","createPlayerMesh","createPhysicsBody","physicsBody","handleCollisions","THREE.CapsuleGeometry","THREE.MeshLambertMaterial","opacity","mesh","THREE.Mesh","castShadow","receiveShadow","set","handleInput","inputState","keys","forward","backward","left","right","up","down","joystick","abs","mobileButtons","swimUp","swimDown","normalize","applyMovement","force","targetRotation","atan2","rotation","THREE.MathUtils","lerp","Date","now","floatingOffset","sin","collision","handleCollectibleCollision","handleObstacleCollision","handleEnvironmentCollision","collectible","console","log","obstacle","direction","getPosition","setPosition","getVelocity","getIsMoving","CONFIG","OceanAdventure","camera","renderer","isLoaded","isMobile","detectMobile","particleSystem","player","environmentObjects","starCount","levelNumber","lastTime","initialize","setupCanvas","setupRenderer","setupScene","setupCamera","setupLights","initializePhysics","initializeParticleSystem","createUnderwaterEnvironment","createPlayer","createSampleStars","setupEventListeners","hideLoading","showUI","startGameLoop","error","getElementById","Error","THREE.WebGLRenderer","antialias","powerPreference","failIfMajorPerformanceCaveat","preserveDrawingBuffer","premultipliedAlpha","stencil","setSize","window","innerWidth","innerHeight","setPixelRatio","devicePixelRatio","setClearColor","shadowMap","enabled","THREE.PCFSoftShadowMap","gl","getExtension","THREE.Scene","THREE.PerspectiveCamera","lookAt","ambientLight","THREE.AmbientLight","directionalLight","THREE.DirectionalLight","shadow","mapSize","near","far","top","bottom","floorGeometry","THREE.PlaneGeometry","floorMaterial","floor","PI","floorPhysicsBody","THREE.SphereGeometry","setHSL","coral","coralPhysicsBody","stars","starGeometry","starMaterial","emissive","emissiveIntensity","star","starPhysicsBody","collected","userData","addEventListener","onWindowResize","event","onKeyDown","onKeyUp","setupTouchControls","setupSettingsModal","code","preventDefault","setupVirtualJoystick","setupMobileButtons","touchState","startX","startY","currentX","currentY","isActive","touches","touch","clientX","clientY","deltaX","deltaY","sensitivity","updateCamera","knob","joystickState","centerX","centerY","stopPropagation","rect","getBoundingClientRect","style","borderColor","background","updateJoystickKnob","distance","sqrt","maxDistance","normalizedX","normalizedY","transform","angle","cos","swimUpBtn","swimDownBtn","settingsButton","settingsModal","closeSettings","openSettings","classList","overflow","closeModal","target","key","contains","aspect","updateProjectionMatrix","playerPosition","offset","targetPosition","animate","currentTime","requestAnimationFrame","render","updateUI","forEach","starData","checkStarCollection","playerCollisions","s","levelComplete","textContent","waterSurface","depth","toFixed","webglErrorCount","warn","loadingElement","uiElement","test","navigator","userAgent","async","game"],"mappings":"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"}